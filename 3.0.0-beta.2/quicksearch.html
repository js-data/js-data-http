<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"node_modules_js-data-adapter_src_index.js.html":{"id":"node_modules_js-data-adapter_src_index.js.html","title":"Source: node_modules/js-data-adapter/src/index.js","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Source: node_modules/js-data-adapter/src/index.js import {utils} from 'js-data' const noop = function (...args) { const self = this const opts = args[args.length - 1] self.dbg(opts.op, ...args) return utils.resolve() } const noop2 = function (...args) { const self = this const opts = args[args.length - 2] self.dbg(opts.op, ...args) return utils.resolve() } const unique = function (array) { const seen = {} const final = [] array.forEach(function (item) { if (item in seen) { return } final.push(item) seen[item] = 0 }) return final } const withoutRelations = function (mapper, props) { return utils.omit(props, mapper.relationFields || []) } const DEFAULTS = { /** * Whether to log debugging information. * * @name Adapter#debug * @type {boolean} * @default false */ debug: false, /** * Whether to return a more detailed response object. * * @name Adapter#raw * @type {boolean} * @default false */ raw: false } /** * Abstract class meant to be extended by adapters. * * @class Adapter * @abstract * @param {Object} [opts] Configuration opts. * @param {boolean} [opts.debug=false] Whether to log debugging information. * @param {boolean} [opts.raw=false] Whether to return a more detailed response * object. */ function Adapter (opts) { const self = this opts || (opts = {}) utils.fillIn(opts, DEFAULTS) utils.fillIn(self, opts) } Adapter.reserved = [ 'orderBy', 'sort', 'limit', 'offset', 'skip', 'where' ] /** * Response object used when `raw` is `true`. May contain other fields in * addition to `data`. * * @typedef {Object} Response * @property {Object} data Response data. * @property {string} op The operation for which the response was created. */ function Response (data, meta, op) { const self = this meta || (meta = {}) self.data = data utils.fillIn(self, meta) self.op = op } Adapter.Response = Response /** * Alternative to ES6 class syntax for extending `Adapter`. * * @name Adapter.extend * @method * @param {Object} [instanceProps] Properties that will be added to the * prototype of the subclass. * @param {Object} [classProps] Properties that will be added as static * properties to the subclass itself. * @return {Object} Subclass of `Adapter`. */ Adapter.extend = utils.extend utils.addHiddenPropsToTarget(Adapter.prototype, { /** * Lifecycle method method called by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the count. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * @name Adapter#afterCount * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @property {string} opts.op `afterCount` * @param {Object|Response} response Count or {@link Response}, depending on the value of `opts.raw`. */ afterCount: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the created record. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * @name Adapter#afterCreate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @property {string} opts.op `afterCreate` * @param {Object|Response} response Created record or {@link Response}, depending on the value of `opts.raw`. */ afterCreate: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the created records. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * @name Adapter#afterCreate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object[]} props The `props` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @property {string} opts.op `afterCreateMany` * @param {Object[]|Response} response Created records or {@link Response}, depending on the value of `opts.raw`. */ afterCreateMany: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be `undefined`. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * @name Adapter#afterDestroy * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @property {string} opts.op `afterDestroy` * @param {undefined|Response} response `undefined` or {@link Response}, depending on the value of `opts.raw`. */ afterDestroy: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be `undefined`. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * @name Adapter#afterDestroyAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @property {string} opts.op `afterDestroyAll` * @param {undefined|Response} response `undefined` or {@link Response}, depending on the value of `opts.raw`. */ afterDestroyAll: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the found record, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * @name Adapter#afterFind * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @property {string} opts.op `afterFind` * @param {Object|Response} response The found record or {@link Response}, depending on the value of `opts.raw`. */ afterFind: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the found records, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * @name Adapter#afterFindAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @property {string} opts.op `afterFindAll` * @param {Object[]|Response} response The found records or {@link Response}, depending on the value of `opts.raw`. */ afterFindAll: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the sum. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * @name Adapter#afterSum * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @property {string} opts.op `afterSum` * @param {Object|Response} response Count or {@link Response}, depending on the value of `opts.raw`. */ afterSum: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the updated record. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * @name Adapter#afterUpdate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @property {string} opts.op `afterUpdate` * @param {Object|Response} response The updated record or {@link Response}, depending on the value of `opts.raw`. */ afterUpdate: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the updated records, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * @name Adapter#afterUpdateAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @property {string} opts.op `afterUpdateAll` * @param {Object[]|Response} response The updated records or {@link Response}, depending on the value of `opts.raw`. */ afterUpdateAll: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the updated records, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * @name Adapter#afterUpdateMany * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object[]} records The `records` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @property {string} opts.op `afterUpdateMany` * @param {Object[]|Response} response The updated records or {@link Response}, depending on the value of `opts.raw`. */ afterUpdateMany: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * @name Adapter#beforeCount * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @property {string} opts.op `beforeCount` */ beforeCount: noop, /** * Lifecycle method method called by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * @name Adapter#beforeCreate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @property {string} opts.op `beforeCreate` */ beforeCreate: noop, /** * Lifecycle method method called by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * @name Adapter#beforeCreateMany * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object[]} props The `props` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @property {string} opts.op `beforeCreateMany` */ beforeCreateMany: noop, /** * Lifecycle method method called by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * @name Adapter#beforeDestroy * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @property {string} opts.op `beforeDestroy` */ beforeDestroy: noop, /** * Lifecycle method method called by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * @name Adapter#beforeDestroyAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @property {string} opts.op `beforeDestroyAll` */ beforeDestroyAll: noop, /** * Lifecycle method method called by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * @name Adapter#beforeFind * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @property {string} opts.op `beforeFind` */ beforeFind: noop, /** * Lifecycle method method called by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * @name Adapter#beforeFindAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @property {string} opts.op `beforeFindAll` */ beforeFindAll: noop, /** * Lifecycle method method called by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * @name Adapter#beforeSum * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @property {string} opts.op `beforeSum` */ beforeSum: noop, /** * Lifecycle method method called by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * @name Adapter#beforeUpdate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @property {string} opts.op `beforeUpdate` */ beforeUpdate: noop, /** * Lifecycle method method called by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * @name Adapter#beforeUpdateAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @property {string} opts.op `beforeUpdateAll` */ beforeUpdateAll: noop, /** * Lifecycle method method called by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * @name Adapter#beforeUpdateMany * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object[]} props The `props` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @property {string} opts.op `beforeUpdateMany` */ beforeUpdateMany: noop, /** * Shortcut for `#log('debug'[, arg1[, arg2[, argn]]])`. * * @name Adapter#dbg * @method */ dbg (...args) { this.log('debug', ...args) }, /** * Retrieve the number of records that match the selection query. Called by * `Mapper#count`. * * @name Adapter#count * @method * @param {Object} mapper The mapper. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ count (mapper, query, opts) { const self = this let op query || (query = {}) opts || (opts = {}) // beforeCount lifecycle hook op = opts.op = 'beforeCount' return utils.resolve(self[op](mapper, query, opts)).then(function () { // Allow for re-assignment from lifecycle hook op = opts.op = 'count' self.dbg(op, mapper, query, opts) return utils.resolve(self._count(mapper, query, opts)) }).then(function (results) { let [data, result] = results result || (result = {}) let response = new Response(data, result, op) response = self.respond(response, opts) // afterCount lifecycle hook op = opts.op = 'afterCount' return utils.resolve(self[op](mapper, query, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Create a new record. Called by `Mapper#create`. * * @name Adapter#create * @method * @param {Object} mapper The mapper. * @param {Object} props The record to be created. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ create (mapper, props, opts) { const self = this let op props || (props = {}) opts || (opts = {}) // beforeCreate lifecycle hook op = opts.op = 'beforeCreate' return utils.resolve(self[op](mapper, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = utils.isUndefined(_props) ? props : _props props = withoutRelations(mapper, props) op = opts.op = 'create' self.dbg(op, mapper, props, opts) return utils.resolve(self._create(mapper, props, opts)) }).then(function (results) { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'create') response.created = data ? 1 : 0 response = self.respond(response, opts) // afterCreate lifecycle hook op = opts.op = 'afterCreate' return utils.resolve(self[op](mapper, props, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Create multiple records in a single batch. Called by `Mapper#createMany`. * * @name Adapter#createMany * @method * @param {Object} mapper The mapper. * @param {Object} props The records to be created. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ createMany (mapper, props, opts) { const self = this let op props || (props = {}) opts || (opts = {}) // beforeCreateMany lifecycle hook op = opts.op = 'beforeCreateMany' return utils.resolve(self[op](mapper, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = utils.isUndefined(_props) ? props : _props props = props.map(function (record) { return withoutRelations(mapper, record) }) op = opts.op = 'createMany' self.dbg(op, mapper, props, opts) return utils.resolve(self._createMany(mapper, props, opts)) }).then(function (results) { let [data, result] = results data || (data = []) result || (result = {}) let response = new Response(data, result, 'createMany') response.created = data.length response = self.respond(response, opts) // afterCreateMany lifecycle hook op = opts.op = 'afterCreateMany' return utils.resolve(self[op](mapper, props, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Destroy the record with the given primary key. Called by * `Mapper#destroy`. * * @name Adapter#destroy * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to destroy. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ destroy (mapper, id, opts) { const self = this let op opts || (opts = {}) // beforeDestroy lifecycle hook op = opts.op = 'beforeDestroy' return utils.resolve(self[op](mapper, id, opts)).then(function () { op = opts.op = 'destroy' self.dbg(op, mapper, id, opts) return utils.resolve(self._destroy(mapper, id, opts)) }).then(function (results) { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'destroy') response = self.respond(response, opts) // afterDestroy lifecycle hook op = opts.op = 'afterDestroy' return utils.resolve(self[op](mapper, id, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Destroy the records that match the selection query. Called by * `Mapper#destroyAll`. * * @name Adapter#destroyAll * @method * @param {Object} mapper the mapper. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ destroyAll (mapper, query, opts) { const self = this let op query || (query = {}) opts || (opts = {}) // beforeDestroyAll lifecycle hook op = opts.op = 'beforeDestroyAll' return utils.resolve(self[op](mapper, query, opts)).then(function () { op = opts.op = 'destroyAll' self.dbg(op, mapper, query, opts) return utils.resolve(self._destroyAll(mapper, query, opts)) }).then(function (results) { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'destroyAll') response = self.respond(response, opts) // afterDestroyAll lifecycle hook op = opts.op = 'afterDestroyAll' return utils.resolve(self[op](mapper, query, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Return the foreignKey from the given record for the provided relationship. * * There may be reasons why you may want to override this method, like when * the id of the parent doesn't exactly match up to the key on the child. * * Override with care. * * @name Adapter#makeHasManyForeignKey * @method * @return {*} */ makeHasManyForeignKey (mapper, def, record) { return def.getForeignKey(record) }, /** * Return the localKeys from the given record for the provided relationship. * * Override with care. * * @name Adapter#makeHasManyLocalKeys * @method * @return {*} */ makeHasManyLocalKeys (mapper, def, record) { let localKeys = [] let itemKeys = utils.get(record, def.localKeys) || [] itemKeys = utils.isArray(itemKeys) ? itemKeys : Object.keys(itemKeys) localKeys = localKeys.concat(itemKeys) return unique(localKeys).filter(function (x) { return x }) }, /** * Return the foreignKeys from the given record for the provided relationship. * * Override with care. * * @name Adapter#makeHasManyForeignKeys * @method * @return {*} */ makeHasManyForeignKeys (mapper, def, record) { return utils.get(record, mapper.idAttribute) }, /** * Load a hasMany relationship. * * Override with care. * * @name Adapter#loadHasMany * @method * @return {Promise} */ loadHasMany (mapper, def, records, __opts) { const self = this let singular = false if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { singular = true records = [records] } const IDs = records.map(function (record) { return self.makeHasManyForeignKey(mapper, def, record) }) const query = { where: {} } const criteria = query.where[def.foreignKey] = {} if (singular) { // more efficient query when we only have one record criteria['=='] = IDs[0] } else { criteria['in'] = IDs.filter(function (id) { return id }) } return self.findAll(def.getRelation(), query, __opts).then(function (relatedItems) { records.forEach(function (record) { let attached = [] // avoid unneccesary iteration when we only have one record if (singular) { attached = relatedItems } else { relatedItems.forEach(function (relatedItem) { if (utils.get(relatedItem, def.foreignKey) === record[mapper.idAttribute]) { attached.push(relatedItem) } }) } def.setLocalField(record, attached) }) }) }, loadHasManyLocalKeys (mapper, def, records, __opts) { const self = this let record const relatedMapper = def.getRelation() if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { record = records } if (record) { return self.findAll(relatedMapper, { where: { [relatedMapper.idAttribute]: { 'in': self.makeHasManyLocalKeys(mapper, def, record) } } }, __opts).then(function (relatedItems) { def.setLocalField(record, relatedItems) }) } else { let localKeys = [] records.forEach(function (record) { localKeys = localKeys.concat(self.self.makeHasManyLocalKeys(mapper, def, record)) }) return self.findAll(relatedMapper, { where: { [relatedMapper.idAttribute]: { 'in': unique(localKeys).filter(function (x) { return x }) } } }, __opts).then(function (relatedItems) { records.forEach(function (item) { let attached = [] let itemKeys = utils.get(item, def.localKeys) || [] itemKeys = utils.isArray(itemKeys) ? itemKeys : Object.keys(itemKeys) relatedItems.forEach(function (relatedItem) { if (itemKeys &amp;&amp; itemKeys.indexOf(relatedItem[relatedMapper.idAttribute]) !== -1) { attached.push(relatedItem) } }) def.setLocalField(item, attached) }) return relatedItems }) } }, loadHasManyForeignKeys (mapper, def, records, __opts) { const self = this const relatedMapper = def.getRelation() const idAttribute = mapper.idAttribute let record if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { record = records } if (record) { return self.findAll(def.getRelation(), { where: { [def.foreignKeys]: { 'contains': self.makeHasManyForeignKeys(mapper, def, record) } } }, __opts).then(function (relatedItems) { def.setLocalField(record, relatedItems) }) } else { return self.findAll(relatedMapper, { where: { [def.foreignKeys]: { 'isectNotEmpty': records.map(function (record) { return self.makeHasManyForeignKeys(mapper, def, record) }) } } }, __opts).then(function (relatedItems) { const foreignKeysField = def.foreignKeys records.forEach(function (record) { const _relatedItems = [] const id = utils.get(record, idAttribute) relatedItems.forEach(function (relatedItem) { const foreignKeys = utils.get(relatedItems, foreignKeysField) || [] if (foreignKeys.indexOf(id) !== -1) { _relatedItems.push(relatedItem) } }) def.setLocalField(record, _relatedItems) }) }) } }, /** * Load a hasOne relationship. * * Override with care. * * @name Adapter#loadHasOne * @method * @return {Promise} */ loadHasOne (mapper, def, records, __opts) { if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { records = [records] } return this.loadHasMany(mapper, def, records, __opts).then(function () { records.forEach(function (record) { const relatedData = def.getLocalField(record) if (utils.isArray(relatedData) &amp;&amp; relatedData.length) { def.setLocalField(record, relatedData[0]) } }) }) }, /** * Return the foreignKey from the given record for the provided relationship. * * Override with care. * * @name Adapter#makeBelongsToForeignKey * @method * @return {*} */ makeBelongsToForeignKey (mapper, def, record) { return def.getForeignKey(record) }, /** * Load a belongsTo relationship. * * Override with care. * * @name Adapter#loadBelongsTo * @method * @return {Promise} */ loadBelongsTo (mapper, def, records, __opts) { const self = this const relationDef = def.getRelation() if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { const record = records return self.find(relationDef, self.makeBelongsToForeignKey(mapper, def, record), __opts).then(function (relatedItem) { def.setLocalField(record, relatedItem) }) } else { const keys = records.map(function (record) { return self.makeBelongsToForeignKey(mapper, def, record) }).filter(function (key) { return key }) return self.findAll(relationDef, { where: { [relationDef.idAttribute]: { 'in': keys } } }, __opts).then(function (relatedItems) { records.forEach(function (record) { relatedItems.forEach(function (relatedItem) { if (relatedItem[relationDef.idAttribute] === record[def.foreignKey]) { def.setLocalField(record, relatedItem) } }) }) }) } }, /** * Retrieve the record with the given primary key. Called by `Mapper#find`. * * @name Adapter#find * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to retrieve. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @param {string[]} [opts.with=[]] Relations to eager load. * @return {Promise} */ find (mapper, id, opts) { const self = this let record, op opts || (opts = {}) opts.with || (opts.with = []) // beforeFind lifecycle hook op = opts.op = 'beforeFind' return utils.resolve(self[op](mapper, id, opts)).then(function () { op = opts.op = 'find' self.dbg(op, mapper, id, opts) return utils.resolve(self._find(mapper, id, opts)) }).then(function (results) { let [_record] = results if (!_record) { return } record = _record const tasks = [] utils.forEachRelation(mapper, opts, function (def, __opts) { let task if (def.foreignKey &amp;&amp; (def.type === 'hasOne' || def.type === 'hasMany')) { if (def.type === 'hasOne') { task = self.loadHasOne(mapper, def, record, __opts) } else { task = self.loadHasMany(mapper, def, record, __opts) } } else if (def.type === 'hasMany' &amp;&amp; def.localKeys) { task = self.loadHasManyLocalKeys(mapper, def, record, __opts) } else if (def.type === 'hasMany' &amp;&amp; def.foreignKeys) { task = self.loadHasManyForeignKeys(mapper, def, record, __opts) } else if (def.type === 'belongsTo') { task = self.loadBelongsTo(mapper, def, record, __opts) } if (task) { tasks.push(task) } }) return Promise.all(tasks) }).then(function () { let response = new Response(record, {}, 'find') response.found = record ? 1 : 0 response = self.respond(response, opts) // afterFind lifecycle hook op = opts.op = 'afterFind' return utils.resolve(self[op](mapper, id, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Retrieve the records that match the selection query. * * @name Adapter#findAll * @method * @param {Object} mapper The mapper. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @param {string[]} [opts.with=[]] Relations to eager load. * @return {Promise} */ findAll (mapper, query, opts) { const self = this opts || (opts = {}) opts.with || (opts.with = []) let records = [] let op const activeWith = opts._activeWith if (utils.isObject(activeWith)) { const activeQuery = activeWith.query || {} if (activeWith.replace) { query = activeQuery } else { utils.deepFillIn(query, activeQuery) } } // beforeFindAll lifecycle hook op = opts.op = 'beforeFindAll' return utils.resolve(self[op](mapper, query, opts)).then(function () { op = opts.op = 'findAll' self.dbg(op, mapper, query, opts) return utils.resolve(self._findAll(mapper, query, opts)) }).then(function (results) { let [_records] = results _records || (_records = []) records = _records const tasks = [] utils.forEachRelation(mapper, opts, function (def, __opts) { let task if (def.foreignKey &amp;&amp; (def.type === 'hasOne' || def.type === 'hasMany')) { if (def.type === 'hasMany') { task = self.loadHasMany(mapper, def, records, __opts) } else { task = self.loadHasOne(mapper, def, records, __opts) } } else if (def.type === 'hasMany' &amp;&amp; def.localKeys) { task = self.loadHasManyLocalKeys(mapper, def, records, __opts) } else if (def.type === 'hasMany' &amp;&amp; def.foreignKeys) { task = self.loadHasManyForeignKeys(mapper, def, records, __opts) } else if (def.type === 'belongsTo') { task = self.loadBelongsTo(mapper, def, records, __opts) } if (task) { tasks.push(task) } }) return Promise.all(tasks) }).then(function () { let response = new Response(records, {}, 'findAll') response.found = records.length response = self.respond(response, opts) // afterFindAll lifecycle hook op = opts.op = 'afterFindAll' return utils.resolve(self[op](mapper, query, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Resolve the value of the specified option based on the given options and * this adapter's settings. Override with care. * * @name Adapter#getOpt * @method * @param {string} opt The name of the option. * @param {Object} [opts] Configuration options. * @return {*} The value of the specified option. */ getOpt (opt, opts) { opts || (opts = {}) return utils.isUndefined(opts[opt]) ? utils.plainCopy(this[opt]) : utils.plainCopy(opts[opt]) }, /** * Logging utility method. Override this method if you want to send log * messages to something other than the console. * * @name Adapter#log * @method * @param {string} level Log level. * @param {...*} values Values to log. */ log (level, ...args) { if (level &amp;&amp; !args.length) { args.push(level) level = 'debug' } if (level === 'debug' &amp;&amp; !this.debug) { return } const prefix = `${level.toUpperCase()}: (Adapter)` if (console[level]) { console[level](prefix, ...args) } else { console.log(prefix, ...args) } }, /** * Retrieve sum of the specified field of the records that match the selection * query. Called by `Mapper#sum`. * * @name Adapter#sum * @method * @param {Object} mapper The mapper. * @param {string} field By to sum. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ sum (mapper, field, query, opts) { const self = this let op if (!utils.isString(field)) { throw new Error('field must be a string!') } query || (query = {}) opts || (opts = {}) // beforeSum lifecycle hook op = opts.op = 'beforeSum' return utils.resolve(self[op](mapper, field, query, opts)).then(function () { // Allow for re-assignment from lifecycle hook op = opts.op = 'sum' self.dbg(op, mapper, field, query, opts) return utils.resolve(self._sum(mapper, field, query, opts)) }).then(function (results) { let [data, result] = results result || (result = {}) let response = new Response(data, result, op) response = self.respond(response, opts) // afterSum lifecycle hook op = opts.op = 'afterSum' return utils.resolve(self[op](mapper, field, query, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * @name Adapter#respond * @method * @param {Object} response Response object. * @param {Object} opts Configuration options. * return {Object} If `opts.raw == true` then return `response`, else return * `response.data`. */ respond (response, opts) { return this.getOpt('raw', opts) ? response : response.data }, /** * Apply the given update to the record with the specified primary key. Called * by `Mapper#update`. * * @name Adapter#update * @method * @param {Object} mapper The mapper. * @param {(string|number)} id The primary key of the record to be updated. * @param {Object} props The update to apply to the record. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ update (mapper, id, props, opts) { const self = this props || (props = {}) opts || (opts = {}) let op // beforeUpdate lifecycle hook op = opts.op = 'beforeUpdate' return utils.resolve(self[op](mapper, id, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = utils.isUndefined(_props) ? props : _props op = opts.op = 'update' self.dbg(op, mapper, id, props, opts) return utils.resolve(self._update(mapper, id, props, opts)) }).then(function (results) { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'update') response.updated = data ? 1 : 0 response = self.respond(response, opts) // afterUpdate lifecycle hook op = opts.op = 'afterUpdate' return utils.resolve(self[op](mapper, id, props, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Apply the given update to all records that match the selection query. * Called by `Mapper#updateAll`. * * @name Adapter#updateAll * @method * @param {Object} mapper The mapper. * @param {Object} props The update to apply to the selected records. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ updateAll (mapper, props, query, opts) { const self = this props || (props = {}) query || (query = {}) opts || (opts = {}) let op // beforeUpdateAll lifecycle hook op = opts.op = 'beforeUpdateAll' return utils.resolve(self[op](mapper, props, query, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = utils.isUndefined(_props) ? props : _props op = opts.op = 'updateAll' self.dbg(op, mapper, props, query, opts) return utils.resolve(self._updateAll(mapper, props, query, opts)) }).then(function (results) { let [data, result] = results data || (data = []) result || (result = {}) let response = new Response(data, result, 'updateAll') response.updated = data.length response = self.respond(response, opts) // afterUpdateAll lifecycle hook op = opts.op = 'afterUpdateAll' return utils.resolve(self[op](mapper, props, query, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Update the given records in a single batch. Called by `Mapper#updateMany`. * * @name Adapter#updateMany * @method * @param {Object} mapper The mapper. * @param {Object[]} records The records to update. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ updateMany (mapper, records, opts) { const self = this records || (records = []) opts || (opts = {}) let op const idAttribute = mapper.idAttribute records = records.filter(function (record) { return utils.get(record, idAttribute) }) // beforeUpdateMany lifecycle hook op = opts.op = 'beforeUpdateMany' return utils.resolve(self[op](mapper, records, opts)).then(function (_records) { // Allow for re-assignment from lifecycle hook records = utils.isUndefined(_records) ? records : _records records = records.map(function (record) { return withoutRelations(mapper, record) }) op = opts.op = 'updateMany' self.dbg(op, mapper, records, opts) return utils.resolve(self._updateMany(mapper, records, opts)) }).then(function (results) { let [data, result] = results data || (data = []) result || (result = {}) let response = new Response(data, result, 'updateMany') response.updated = data.length response = self.respond(response, opts) // afterUpdateMany lifecycle hook op = opts.op = 'afterUpdateMany' return utils.resolve(self[op](mapper, records, opts, response)).then(function (_response) { // Allow for re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) } }) module.exports = Adapter  Search results Close Back to js-data.io "},"src_index.js.html":{"id":"src_index.js.html","title":"Source: src/index.js","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Source: src/index.js /* global fetch:true Headers:true Request:true */ const axios = require('axios') import {utils} from 'js-data' import Adapter from 'js-data-adapter' let hasFetch = false try { hasFetch = window &amp;&amp; window.fetch } catch (e) {} const noop = function (...args) { const self = this const opts = args[args.length - 1] self.dbg(opts.op, ...args) return utils.resolve() } const noop2 = function (...args) { const self = this const opts = args[args.length - 2] self.dbg(opts.op, ...args) return utils.resolve() } function isValidString (value) { return (value != null &amp;&amp; value !== '') } function join (items, separator) { separator || (separator = '') return items.filter(isValidString).join(separator) } function makePath (...args) { let result = join(args, '/') return result.replace(/([^:\\/]|^)\\/{2,}/g, '$1/') } function encode (val) { return encodeURIComponent(val) .replace(/%40/gi, '@') .replace(/%3A/gi, ':') .replace(/%24/g, '$') .replace(/%2C/gi, ',') .replace(/%20/g, '+') .replace(/%5B/gi, '[') .replace(/%5D/gi, ']') } function buildUrl (url, params) { if (!params) { return url } const parts = [] utils.forOwn(params, function (val, key) { if (val === null || typeof val === 'undefined') { return } if (!utils.isArray(val)) { val = [val] } val.forEach(function (v) { if (window.toString.call(v) === '[object Date]') { v = v.toISOString() } else if (utils.isObject(v)) { v = utils.toJson(v) } parts.push(`${encode(key)}=${encode(v)}`) }) }) if (parts.length &gt; 0) { url += (url.indexOf('?') === -1 ? '?' : '&amp;') + parts.join('&amp;') } return url } const __super__ = Adapter.prototype const DEFAULTS = { // Default and user-defined settings /** * @name HttpAdapter#basePath * @type {string} */ basePath: '', /** * @name HttpAdapter#forceTrailingSlash * @type {boolean} * @default false */ forceTrailingSlash: false, /** * @name HttpAdapter#http * @type {Function} */ http: axios, /** * @name HttpAdapter#httpConfig * @type {Object} */ httpConfig: {}, /** * @name HttpAdapter#suffix * @type {string} */ suffix: '', /** * @name HttpAdapter#useFetch * @type {boolean} * @default false */ useFetch: false } /** * HttpAdapter class. * * @class HttpAdapter * @param {Object} [opts] Configuration options. * @param {string} [opts.basePath=''] TODO * @param {boolean} [opts.debug=false] TODO * @param {boolean} [opts.forceTrailingSlash=false] TODO * @param {Object} [opts.http=axios] TODO * @param {Object} [opts.httpConfig={}] TODO * @param {string} [opts.suffix=''] TODO * @param {boolean} [opts.useFetch=false] TODO */ function HttpAdapter (opts) { const self = this opts || (opts = {}) utils.fillIn(opts, DEFAULTS) Adapter.call(self, opts) } // Setup prototype inheritance from Adapter HttpAdapter.prototype = Object.create(Adapter.prototype, { constructor: { value: HttpAdapter, enumerable: false, writable: true, configurable: true } }) Object.defineProperty(HttpAdapter, '__super__', { configurable: true, value: Adapter }) utils.addHiddenPropsToTarget(HttpAdapter.prototype, { /** * @name HttpAdapter#afterDEL * @method * @param {string} url * @param {Object} config * @param {Object} opts * @param {Object} response */ afterDEL: noop2, /** * @name HttpAdapter#afterGET * @method * @param {string} url * @param {Object} config * @param {Object} opts * @param {Object} response */ afterGET: noop2, /** * @name HttpAdapter#afterHTTP * @method * @param {Object} config * @param {Object} opts * @param {Object} response */ afterHTTP: noop2, /** * @name HttpAdapter#afterPOST * @method * @param {string} url * @param {Object} data * @param {Object} config * @param {Object} opts * @param {Object} response */ afterPOST: noop2, /** * @name HttpAdapter#afterPUT * @method * @param {string} url * @param {Object} data * @param {Object} config * @param {Object} opts * @param {Object} response */ afterPUT: noop2, /** * @name HttpAdapter#beforeDEL * @method * @param {Object} url * @param {Object} config * @param {Object} opts */ beforeDEL: noop, /** * @name HttpAdapter#beforeGET * @method * @param {Object} url * @param {Object} config * @param {Object} opts */ beforeGET: noop, /** * @name HttpAdapter#beforeHTTP * @method * @param {Object} config * @param {Object} opts */ beforeHTTP: noop, /** * @name HttpAdapter#beforePOST * @method * @param {Object} url * @param {Object} data * @param {Object} config * @param {Object} opts */ beforePOST: noop, /** * @name HttpAdapter#beforePUT * @method * @param {Object} url * @param {Object} data * @param {Object} config * @param {Object} opts */ beforePUT: noop, _count (mapper, query, opts) { const self = this return self.GET( self.getPath('count', mapper, opts.params, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _create (mapper, props, opts) { const self = this return self.POST( self.getPath('create', mapper, props, opts), self.serialize(mapper, props, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _createMany (mapper, props, opts) { const self = this return self.POST( self.getPath('createMany', mapper, null, opts), self.serialize(mapper, props, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _destroy (mapper, id, opts) { const self = this return self.DEL( self.getPath('destroy', mapper, id, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _destroyAll (mapper, query, opts) { const self = this return self.DEL( self.getPath('destroyAll', mapper, null, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _end (mapper, opts, response) { return [this.deserialize(mapper, response, opts), response] }, _find (mapper, id, opts) { const self = this return self.GET( self.getPath('find', mapper, id, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _findAll (mapper, query, opts) { const self = this return self.GET( self.getPath('findAll', mapper, opts.params, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _sum (mapper, field, query, opts) { const self = this return self.GET( self.getPath('sum', mapper, opts.params, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _update (mapper, id, props, opts) { const self = this return self.PUT( self.getPath('update', mapper, id, opts), self.serialize(mapper, props, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _updateAll (mapper, props, query, opts) { const self = this return self.PUT( self.getPath('updateAll', mapper, null, opts), self.serialize(mapper, props, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, _updateMany (mapper, records, opts) { const self = this return self.PUT( self.getPath('updateMany', mapper, null, opts), self.serialize(mapper, records, opts), opts ).then(function (response) { return self._end(mapper, opts, response) }) }, /** * Retrieve the number of records that match the selection `query`. * * @name HttpAdapter#count * @method * @param {Object} mapper The mapper. * @param {Object} query Selection query. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ count (mapper, query, opts) { const self = this query || (query = {}) opts || (opts = {}) opts.params = self.getParams(opts) opts.params.count = true opts.suffix = self.getSuffix(mapper, opts) utils.deepMixIn(opts.params, query) opts.params = self.queryTransform(mapper, opts.params, opts) return __super__.count.call(self, mapper, query, opts) }, /** * Create a new the record from the provided `props`. * * @name HttpAdapter#create * @method * @param {Object} mapper The mapper. * @param {Object} props Properties to send as the payload. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ create (mapper, props, opts) { const self = this opts || (opts = {}) opts.params = self.getParams(opts) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.create.call(self, mapper, props, opts) }, /** * Create multiple new records in batch. * * @name HttpAdapter#createMany * @method * @param {Object} mapper The mapper. * @param {Array} props Array of property objects to send as the payload. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ createMany (mapper, props, opts) { const self = this opts || (opts = {}) opts.params = self.getParams(opts) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.createMany.call(self, mapper, props, opts) }, /** * Make an Http request to `url` according to the configuration in `config`. * * @name HttpAdapter#DEL * @method * @param {string} url Url for the request. * @param {Object} [config] Http configuration that will be passed to * {@link HttpAdapter#HTTP}. * @param {Object} [opts] Configuration options. * @return {Promise} */ DEL (url, config, opts) { const self = this let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.method = config.method || 'delete' // beforeDEL lifecycle hook op = opts.op = 'beforeDEL' return utils.resolve(self[op](url, config, opts)).then(function (_config) { // Allow re-assignment from lifecycle hook config = utils.isUndefined(_config) ? config : _config op = opts.op = 'DEL' self.dbg(op, url, config, opts) return self.HTTP(config, opts) }).then(function (response) { // afterDEL lifecycle hook op = opts.op = 'afterDEL' return utils.resolve(self[op](url, config, opts, response)).then(function (_response) { // Allow re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * Transform the server response object into the payload that will be returned * to JSData. * * @name HttpAdapter#deserialize * @method * @param {Object} mapper The mapper used for the operation. * @param {Object} response Response object from {@link HttpAdapter#HTTP}. * @param {Object} opts Configuration options. * @return {(Object|Array)} Deserialized data. */ deserialize (mapper, response, opts) { opts || (opts = {}) if (utils.isFunction(opts.deserialize)) { return opts.deserialize(mapper, response, opts) } if (utils.isFunction(mapper.deserialize)) { return mapper.deserialize(mapper, response, opts) } if (response &amp;&amp; response.hasOwnProperty('data')) { return response.data } return response }, /** * Destroy the record with the given primary key. * * @name HttpAdapter#destroy * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to destroy. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ destroy (mapper, id, opts) { const self = this opts || (opts = {}) opts.params = self.getParams(opts) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.destroy.call(self, mapper, id, opts) }, /** * Destroy the records that match the selection `query`. * * @name HttpAdapter#destroyAll * @method * @param {Object} mapper The mapper. * @param {Object} query Selection query. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ destroyAll (mapper, query, opts) { const self = this query || (query = {}) opts || (opts = {}) opts.params = self.getParams(opts) utils.deepMixIn(opts.params, query) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.destroyAll.call(self, mapper, query, opts) }, /** * Log an error. * * @name HttpAdapter#error * @method * @param {...*} [args] Arguments to log. */ error (...args) { if (console) { console[typeof console.error === 'function' ? 'error' : 'log'](...args) } }, /** * Make an Http request using `window.fetch`. * * @name HttpAdapter#fetch * @method * @param {Object} config Request configuration. * @param {Object} config.data Payload for the request. * @param {string} config.method Http method for the request. * @param {Object} config.headers Headers for the request. * @param {Object} config.params Querystring for the request. * @param {string} config.url Url for the request. * @param {Object} [opts] Configuration options. */ fetch (config, opts) { const requestConfig = { method: config.method, // turn the plain headers object into the Fetch Headers object headers: new Headers(config.headers) } if (config.data) { requestConfig.body = utils.toJson(config.data) } return fetch(new Request(buildUrl(config.url, config.params), requestConfig)).then(function (response) { response.config = { method: config.method, url: config.url } return response.json().then(function (data) { response.data = data return response }) }) }, /** * Retrieve the record with the given primary key. * * @name HttpAdapter#find * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to retrieve. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ find (mapper, id, opts) { const self = this opts || (opts = {}) opts.params = self.getParams(opts) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.find.call(self, mapper, id, opts) }, /** * Retrieve the records that match the selection `query`. * * @name HttpAdapter#findAll * @method * @param {Object} mapper The mapper. * @param {Object} query Selection query. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ findAll (mapper, query, opts) { const self = this query || (query = {}) opts || (opts = {}) opts.params = self.getParams(opts) opts.suffix = self.getSuffix(mapper, opts) utils.deepMixIn(opts.params, query) opts.params = self.queryTransform(mapper, opts.params, opts) return __super__.findAll.call(self, mapper, query, opts) }, /** * TODO * * @name HttpAdapter#GET * @method * @param {string} url The url for the request. * @param {Object} config Request configuration options. * @param {Object} [opts] Configuration options. * @return {Promise} */ GET (url, config, opts) { const self = this let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.method = config.method || 'get' // beforeGET lifecycle hook op = opts.op = 'beforeGET' return utils.resolve(self[op](url, config, opts)).then(function (_config) { // Allow re-assignment from lifecycle hook config = utils.isUndefined(_config) ? config : _config op = opts.op = 'GET' self.dbg(op, url, config, opts) return self.HTTP(config, opts) }).then(function (response) { // afterGET lifecycle hook op = opts.op = 'afterGET' return utils.resolve(self[op](url, config, opts, response)).then(function (_response) { // Allow re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * @name HttpAdapter#getEndpoint * @method * @param {Object} mapper TODO * @param {*} id TODO * @param {boolean} opts TODO * @return {string} Full path. */ getEndpoint (mapper, id, opts) { const self = this opts || (opts = {}) opts.params = utils.isUndefined(opts.params) ? {} : opts.params const relationList = mapper.relationList || [] let endpoint = utils.isUndefined(opts.endpoint) ? (utils.isUndefined(mapper.endpoint) ? mapper.name : mapper.endpoint) : opts.endpoint relationList.forEach(function (def) { if (def.type !== 'belongsTo' || !def.parent) { return } let item const parentKey = def.foreignKey const parentDef = def.getRelation() let parentId = opts.params[parentKey] if (parentId === false || !parentKey || !parentDef) { if (parentId === false) { delete opts.params[parentKey] } return false } else { delete opts.params[parentKey] if (utils.isObject(id)) { item = id } if (item) { parentId = parentId || def.getForeignKey(item) || (def.getLocalField(item) ? utils.get(def.getLocalField(item), parentDef.idAttribute) : null) } if (parentId) { delete opts.endpoint const _opts = {} utils.forOwn(opts, function (value, key) { _opts[key] = value }) utils._(_opts, parentDef) endpoint = makePath(self.getEndpoint(parentDef, parentId, _opts), parentId, endpoint) return false } } }) return endpoint }, /** * @name HttpAdapter#getPath * @method * @param {string} method TODO * @param {Object} mapper TODO * @param {(string|number)?} id TODO * @param {Object} opts Configuration options. */ getPath (method, mapper, id, opts) { const self = this opts || (opts = {}) const args = [ utils.isUndefined(opts.basePath) ? (utils.isUndefined(mapper.basePath) ? self.basePath : mapper.basePath) : opts.basePath, self.getEndpoint(mapper, (utils.isString(id) || utils.isNumber(id) || method === 'create') ? id : null, opts) ] if (method === 'find' || method === 'update' || method === 'destroy') { args.push(id) } return makePath.apply(utils, args) }, getParams (opts) { opts || (opts = {}) if (utils.isUndefined(opts.params)) { return {} } return utils.copy(opts.params) }, getSuffix (mapper, opts) { opts || (opts = {}) if (utils.isUndefined(opts.suffix)) { if (utils.isUndefined(mapper.suffix)) { return this.suffix } return mapper.suffix } return opts.suffix }, /** * Make an Http request. * * @name HttpAdapter#HTTP * @method * @param {Object} config Request configuration options. * @param {Object} [opts] Configuration options. * @return {Promise} */ HTTP (config, opts) { const self = this const start = new Date() opts || (opts = {}) const payload = config.data const cache = config.cache const timeout = config.timeout config = utils.copy(config, null, null, null, ['data', 'cache', 'timeout']) config = utils.deepMixIn(config, self.httpConfig) config.data = payload config.cache = cache config.timeout = timeout if (self.forceTrailingSlash &amp;&amp; config.url[config.url.length - 1] !== '/') { config.url += '/' } config.method = config.method.toUpperCase() const suffix = config.suffix || opts.suffix || self.suffix if (suffix &amp;&amp; config.url.substr(config.url.length - suffix.length) !== suffix) { config.url += suffix } function logResponse (data) { const str = `${start.toUTCString()} - ${config.method.toUpperCase()} ${config.url} - ${data.status} ${(new Date().getTime() - start.getTime())}ms` if (data.status &gt;= 200 &amp;&amp; data.status &lt; 300) { if (self.log) { self.dbg('debug', str, data) } return data } else { if (self.error) { self.error(`'FAILED: ${str}`, data) } return utils.reject(data) } } if (!self.http) { throw new Error('You have not configured this adapter with an http library!') } return utils.resolve(self.beforeHTTP(config, opts)).then(function (_config) { config = _config || config if (hasFetch &amp;&amp; (self.useFetch || opts.useFetch || !self.http)) { return self.fetch(config, opts).then(logResponse, logResponse) } return self.http(config).then(logResponse, logResponse).catch(function (err) { return self.responseError(err, config, opts) }) }).then(function (response) { return utils.resolve(self.afterHTTP(config, opts, response)).then(function (_response) { return _response || response }) }) }, /** * TODO * * @name HttpAdapter#POST * @method * @param {*} url TODO * @param {Object} data TODO * @param {Object} config TODO * @param {Object} [opts] Configuration options. * @return {Promise} */ POST (url, data, config, opts) { const self = this let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.data = data || config.data config.method = config.method || 'post' // beforePOST lifecycle hook op = opts.op = 'beforePOST' return utils.resolve(self[op](url, data, config, opts)).then(function (_config) { // Allow re-assignment from lifecycle hook config = utils.isUndefined(_config) ? config : _config op = opts.op = 'POST' self.dbg(op, url, data, config, opts) return self.HTTP(config, opts) }).then(function (response) { // afterPOST lifecycle hook op = opts.op = 'afterPOST' return utils.resolve(self[op](url, data, config, opts, response)).then(function (_response) { // Allow re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * TODO * * @name HttpAdapter#PUT * @method * @param {*} url TODO * @param {Object} data TODO * @param {Object} config TODO * @param {Object} [opts] Configuration options. * @return {Promise} */ PUT (url, data, config, opts) { const self = this let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.data = data || config.data config.method = config.method || 'put' // beforePUT lifecycle hook op = opts.op = 'beforePUT' return utils.resolve(self[op](url, data, config, opts)).then(function (_config) { // Allow re-assignment from lifecycle hook config = utils.isUndefined(_config) ? config : _config op = opts.op = 'PUT' self.dbg(op, url, data, config, opts) return self.HTTP(config, opts) }).then(function (response) { // afterPUT lifecycle hook op = opts.op = 'afterPUT' return utils.resolve(self[op](url, data, config, opts, response)).then(function (_response) { // Allow re-assignment from lifecycle hook return utils.isUndefined(_response) ? response : _response }) }) }, /** * TODO * * @name HttpAdapter#queryTransform * @method * @param {Object} mapper TODO * @param {*} params TODO * @param {*} opts TODO * @return {*} Transformed params. */ queryTransform (mapper, params, opts) { opts || (opts = {}) if (utils.isFunction(opts.queryTransform)) { return opts.queryTransform(mapper, params, opts) } if (utils.isFunction(mapper.queryTransform)) { return mapper.queryTransform(mapper, params, opts) } return params }, /** * Error handler invoked when the promise returned by {@link HttpAdapter#http} * is rejected. Default implementation is to just return the error wrapped in * a rejected Promise, aka rethrow the error. {@link HttpAdapter#http} is * called by {@link HttpAdapter#HTTP}. * * @name HttpAdapter#responseError * @method * @param {*} err The error that {@link HttpAdapter#http} rejected with. * @param {Object} config The `config` argument that was passed to {@link HttpAdapter#HTTP}. * @param {*} opts The `opts` argument that was passed to {@link HttpAdapter#HTTP}. * @return {Promise} */ responseError (err, config, opts) { return utils.reject(err) }, /** * TODO * * @name HttpAdapter#serialize * @method * @param {Object} mapper TODO * @param {Object} data TODO * @param {*} opts TODO * @return {*} Serialized data. */ serialize (mapper, data, opts) { opts || (opts = {}) if (utils.isFunction(opts.serialize)) { return opts.serialize(mapper, data, opts) } if (utils.isFunction(mapper.serialize)) { return mapper.serialize(mapper, data, opts) } return data }, /** * Retrieve the sum of the field of the records that match the selection query. * * @name HttpAdapter#sum * @method * @param {Object} mapper The mapper. * @param {string} field The field to sum. * @param {Object} query Selection query. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ sum (mapper, field, query, opts) { const self = this query || (query = {}) opts || (opts = {}) if (!utils.utils.isString(field)) { throw new Error('field must be a string!') } opts.params = self.getParams(opts) opts.params.sum = field opts.suffix = self.getSuffix(mapper, opts) utils.deepMixIn(opts.params, query) opts.params = self.queryTransform(mapper, opts.params, opts) return __super__.sum.call(self, mapper, field, query, opts) }, /** * TODO * * @name HttpAdapter#update * @method * @param {Object} mapper TODO * @param {*} id TODO * @param {*} props TODO * @param {Object} [opts] Configuration options. * @return {Promise} */ update (mapper, id, props, opts) { const self = this opts || (opts = {}) opts.params = self.getParams(opts) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.update.call(self, mapper, id, props, opts) }, /** * TODO * * @name HttpAdapter#updateAll * @method * @param {Object} mapper TODO * @param {Object} props TODO * @param {Object} query TODO * @param {Object} [opts] Configuration options. * @return {Promise} */ updateAll (mapper, props, query, opts) { const self = this query || (query = {}) opts || (opts = {}) opts.params = self.getParams(opts) utils.deepMixIn(opts.params, query) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.updateAll.call(self, mapper, props, query, opts) }, /** * Update multiple records in batch. * * {@link HttpAdapter#beforeUpdateMany} will be called before calling * {@link HttpAdapter#PUT}. * {@link HttpAdapter#afterUpdateMany} will be called after calling * {@link HttpAdapter#PUT}. * * @name HttpAdapter#updateMany * @method * @param {Object} mapper The mapper. * @param {Array} records Array of property objects to send as the payload. * @param {Object} [opts] Configuration options. * @param {string} [opts.params] TODO * @param {string} [opts.suffix={@link HttpAdapter#suffix}] TODO * @return {Promise} */ updateMany (mapper, records, opts) { const self = this opts || (opts = {}) opts.params = self.getParams(opts) opts.params = self.queryTransform(mapper, opts.params, opts) opts.suffix = self.getSuffix(mapper, opts) return __super__.updateMany.call(self, mapper, records, opts) } }) /** * Add an Http actions to a mapper. * * @name HttpAdapter.addAction * @method * @param {string} name Name of the new action. * @param {Object} [opts] Action configuration * @param {string} [opts.adapter] * @param {string} [opts.pathname] * @param {Function} [opts.request] * @param {Function} [opts.response] * @param {Function} [opts.responseError] * @return {Function} Decoration function, which should be passed the mapper to * decorate when invoked. */ HttpAdapter.addAction = function (name, opts) { if (!name || !utils.isString(name)) { throw new TypeError('action(name[, opts]): Expected: string, Found: ' + typeof name) } return function (mapper) { if (mapper[name]) { throw new Error('action(name[, opts]): ' + name + ' already exists on target!') } opts.request = opts.request || function (config) { return config } opts.response = opts.response || function (response) { return response } opts.responseError = opts.responseError || function (err) { return utils.reject(err) } mapper[name] = function (id, _opts) { const self = this if (utils.isObject(id)) { _opts = id } _opts = _opts || {} let adapter = self.getAdapter(opts.adapter || self.defaultAdapter || 'http') let config = {} utils.fillIn(config, opts) if (!_opts.hasOwnProperty('endpoint') &amp;&amp; config.endpoint) { _opts.endpoint = config.endpoint } if (typeof _opts.getEndpoint === 'function') { config.url = _opts.getEndpoint(self, _opts) } else { let args = [ _opts.basePath || self.basePath || adapter.basePath, adapter.getEndpoint(self, utils.isSorN(id) ? id : null, _opts) ] if (utils.isSorN(id)) { args.push(id) } args.push(opts.pathname || name) config.url = makePath.apply(null, args) } config.method = config.method || 'GET' config.mapper = self.name utils.deepMixIn(config)(_opts) return utils.resolve(config) .then(_opts.request || opts.request) .then(function (config) { return adapter.HTTP(config) }) .then(function (data) { if (data &amp;&amp; data.config) { data.config.mapper = self.name } return data }) .then(_opts.response || opts.response, _opts.responseError || opts.responseError) } return mapper } } /** * Add multiple Http actions to a mapper. See {@link HttpAdapter.addAction} for * action configuration options. * * @name HttpAdapter.addActions * @method * @param {Object.&lt;string, Object&gt;} opts Object where the key is an action name * and the value is the configuration for the action. * @return {Function} Decoration function, which should be passed the mapper to * decorate when invoked. */ HttpAdapter.addActions = function (opts) { opts || (opts = {}) return function (mapper) { utils.forOwn(mapper, function (value, key) { HttpAdapter.addAction(key, value)(mapper) }) return mapper } } /** * Alternative to ES6 class syntax for extending `HttpAdapter`. * * __ES6__: * ```javascript * class MyHttpAdapter extends HttpAdapter { * deserialize (Model, data, opts) { * const data = super.deserialize(Model, data, opts) * data.foo = 'bar' * return data * } * } * ``` * * __ES5__: * ```javascript * var instanceProps = { * // override deserialize * deserialize: function (Model, data, opts) { * var Ctor = this.constructor * var superDeserialize = (Ctor.__super__ || Object.getPrototypeOf(Ctor)).deserialize * // call the super deserialize * var data = superDeserialize(Model, data, opts) * data.foo = 'bar' * return data * }, * say: function () { return 'hi' } * } * var classProps = { * yell: function () { return 'HI' } * } * * var MyHttpAdapter = HttpAdapter.extend(instanceProps, classProps) * var adapter = new MyHttpAdapter() * adapter.say() // &quot;hi&quot; * MyHttpAdapter.yell() // &quot;HI&quot; * ``` * * @name HttpAdapter.extend * @method * @param {Object} [instanceProps] Properties that will be added to the * prototype of the subclass. * @param {Object} [classProps] Properties that will be added as static * properties to the subclass itself. * @return {Object} Subclass of `HttpAdapter`. */ HttpAdapter.extend = utils.extend /** * Details of the current version of the `js-data-http` module. * * @name HttpAdapter.version * @type {Object} * @property {string} version.full The full semver value. * @property {number} version.major The major version number. * @property {number} version.minor The minor version number. * @property {number} version.patch The patch version number. * @property {(string|boolean)} version.alpha The alpha version value, * otherwise `false` if the current version is not alpha. * @property {(string|boolean)} version.beta The beta version value, * otherwise `false` if the current version is not beta. */ HttpAdapter.version = '&lt;%= version %&gt;' /** * Registered as `js-data-http` in NPM and Bower. The build of `js-data-http` * that works on Node.js is registered in NPM as `js-data-http-node`. The build * of `js-data-http` that does not bundle `axios` is registered in NPM and Bower * as `js-data-fetch`. * * __Script tag__: * ```javascript * window.HttpAdapter * ``` * __CommonJS__: * ```javascript * var HttpAdapter = require('js-data-http') * ``` * __ES6 Modules__: * ```javascript * import HttpAdapter from 'js-data-http' * ``` * __AMD__: * ```javascript * define('myApp', ['js-data-http'], function (HttpAdapter) { ... }) * ``` * * @module js-data-http */ module.exports = HttpAdapter  Search results Close Back to js-data.io "},"global.html":{"id":"global.html","title":"Global","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Global Type Definitions Response Response object used when raw is true. May contain other fields in addition to data. Type: Object Properties: Name Type Description data Object Response data. op string The operation for which the response was created. Source: node_modules/js-data-adapter/src/index.js, line 80  Search results Close Back to js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Modules Classes Adapter HttpAdapter  Search results Close Back to js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Classes Classes Adapter HttpAdapter  Search results Close Back to js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global js-data-http 3.0.0-beta.2 js-data-http This repo contains HTTP adapters for js-data: js-data-http - HTTP (XHR, includes [axios][axios]) adapter for js-data in the browser. Capable of using window.fetch instead of axios. js-data-fetch - Same as js-data-http but doesn't include axios and will use window.fetch if available and if you don't provide your own http library. js-data-http-node - Same as js-data-http but runs on Node.js. Depends on axios and will use axios unless you provide a different http library. Tested on IE9, Chrome 46, Firefox 41 &amp; Safari 7.1 using To get started, visit the main website at http://js-data.io. Links Quick start Guides and Tutorials API Reference Docs Community Support Contributing LicenseThe MIT License (MIT) Copyright (c) 2014-2016 js-data-http project authors LICENSE AUTHORS CONTRIBUTORS  Search results Close Back to js-data.io "},"Adapter.html":{"id":"Adapter.html","title":"Class: Adapter","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Class: Adapter Adapter &lt;abstract&gt; new Adapter(opts) Abstract class meant to be extended by adapters. Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration opts. Properties Name Type Argument Default Description debug boolean &lt;optional&gt; false Whether to log debugging information. raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 54 Members debug :boolean Whether to log debugging information. Type: boolean Default Value: false Source: node_modules/js-data-adapter/src/index.js, line 35 raw :boolean Whether to return a more detailed response object. Type: boolean Default Value: false Source: node_modules/js-data-adapter/src/index.js, line 44 Methods &lt;static&gt; extend(instanceProps, classProps) Alternative to ES6 class syntax for extending Adapter. Parameters: Name Type Argument Description instanceProps Object &lt;optional&gt; Properties that will be added to the prototype of the subclass. classProps Object &lt;optional&gt; Properties that will be added as static properties to the subclass itself. Source: node_modules/js-data-adapter/src/index.js, line 98 Returns: Subclass of Adapter. Type Object afterCount(mapper, props, opts, response) Lifecycle method method called by count. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes count to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the count. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by count. Parameters: Name Type Description mapper Object The mapper argument passed to count. props Object The props argument passed to count. opts Object The opts argument passed to count. response Object | Response Count or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterCount Source: node_modules/js-data-adapter/src/index.js, line 112 afterCreate(mapper, props, opts, response) Lifecycle method method called by createMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes createMany to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the created records. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by createMany. Parameters: Name Type Description mapper Object The mapper argument passed to createMany. props Array.&lt;Object&gt; The props argument passed to createMany. opts Object The opts argument passed to createMany. response Array.&lt;Object&gt; | Response Created records or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterCreateMany Source: node_modules/js-data-adapter/src/index.js, line 158 afterCreate(mapper, props, opts, response) Lifecycle method method called by create. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes create to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the created record. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by create. Parameters: Name Type Description mapper Object The mapper argument passed to create. props Object The props argument passed to create. opts Object The opts argument passed to create. response Object | Response Created record or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterCreate Source: node_modules/js-data-adapter/src/index.js, line 135 afterDestroy(mapper, id, opts, response) Lifecycle method method called by destroy. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroy to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be undefined. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroy. Parameters: Name Type Description mapper Object The mapper argument passed to destroy. id string | number The id argument passed to destroy. opts Object The opts argument passed to destroy. response undefined | Response undefined or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterDestroy Source: node_modules/js-data-adapter/src/index.js, line 181 afterDestroyAll(mapper, query, opts, response) Lifecycle method method called by destroyAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroyAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be undefined. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroyAll. Parameters: Name Type Description mapper Object The mapper argument passed to destroyAll. query Object The query argument passed to destroyAll. opts Object The opts argument passed to destroyAll. response undefined | Response undefined or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterDestroyAll Source: node_modules/js-data-adapter/src/index.js, line 204 afterFind(mapper, id, opts, response) Lifecycle method method called by find. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes find to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the found record, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by find. Parameters: Name Type Description mapper Object The mapper argument passed to find. id string | number The id argument passed to find. opts Object The opts argument passed to find. response Object | Response The found record or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterFind Source: node_modules/js-data-adapter/src/index.js, line 227 afterFindAll(mapper, query, opts, response) Lifecycle method method called by findAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes findAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the found records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by findAll. Parameters: Name Type Description mapper Object The mapper argument passed to findAll. query Object The query argument passed to findAll. opts Object The opts argument passed to findAll. response Array.&lt;Object&gt; | Response The found records or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterFindAll Source: node_modules/js-data-adapter/src/index.js, line 250 afterSum(mapper, props, opts, response) Lifecycle method method called by sum. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes sum to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the sum. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by sum. Parameters: Name Type Description mapper Object The mapper argument passed to sum. props Object The props argument passed to sum. opts Object The opts argument passed to sum. response Object | Response Count or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterSum Source: node_modules/js-data-adapter/src/index.js, line 273 afterUpdate(mapper, id, props, opts, response) Lifecycle method method called by update. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes update to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated record. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by update. Parameters: Name Type Description mapper Object The mapper argument passed to update. id string | number The id argument passed to update. props Object The props argument passed to update. opts Object The opts argument passed to update. response Object | Response The updated record or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterUpdate Source: node_modules/js-data-adapter/src/index.js, line 296 afterUpdateAll(mapper, props, query, opts, response) Lifecycle method method called by updateAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateAll. Parameters: Name Type Description mapper Object The mapper argument passed to updateAll. props Object The props argument passed to updateAll. query Object The query argument passed to updateAll. opts Object The opts argument passed to updateAll. response Array.&lt;Object&gt; | Response The updated records or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterUpdateAll Source: node_modules/js-data-adapter/src/index.js, line 320 afterUpdateMany(mapper, records, opts, response) Lifecycle method method called by updateMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateMany to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateMany. Parameters: Name Type Description mapper Object The mapper argument passed to updateMany. records Array.&lt;Object&gt; The records argument passed to updateMany. opts Object The opts argument passed to updateMany. response Array.&lt;Object&gt; | Response The updated records or Response, depending on the value of opts.raw. Properties: Name Type Description opts.op string afterUpdateMany Source: node_modules/js-data-adapter/src/index.js, line 344 beforeCount(mapper, query, opts) Lifecycle method method called by count. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes count to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by count. Parameters: Name Type Description mapper Object The mapper argument passed to count. query Object The query argument passed to count. opts Object The opts argument passed to count. Properties: Name Type Description opts.op string beforeCount Source: node_modules/js-data-adapter/src/index.js, line 367 beforeCreate(mapper, props, opts) Lifecycle method method called by create. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes create to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by create. Parameters: Name Type Description mapper Object The mapper argument passed to create. props Object The props argument passed to create. opts Object The opts argument passed to create. Properties: Name Type Description opts.op string beforeCreate Source: node_modules/js-data-adapter/src/index.js, line 385 beforeCreateMany(mapper, props, opts) Lifecycle method method called by createMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes createMany to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by createMany. Parameters: Name Type Description mapper Object The mapper argument passed to createMany. props Array.&lt;Object&gt; The props argument passed to createMany. opts Object The opts argument passed to createMany. Properties: Name Type Description opts.op string beforeCreateMany Source: node_modules/js-data-adapter/src/index.js, line 405 beforeDestroy(mapper, id, opts) Lifecycle method method called by destroy. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroy to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroy. Parameters: Name Type Description mapper Object The mapper argument passed to destroy. id string | number The id argument passed to destroy. opts Object The opts argument passed to destroy. Properties: Name Type Description opts.op string beforeDestroy Source: node_modules/js-data-adapter/src/index.js, line 425 beforeDestroyAll(mapper, query, opts) Lifecycle method method called by destroyAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroyAll to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroyAll. Parameters: Name Type Description mapper Object The mapper argument passed to destroyAll. query Object The query argument passed to destroyAll. opts Object The opts argument passed to destroyAll. Properties: Name Type Description opts.op string beforeDestroyAll Source: node_modules/js-data-adapter/src/index.js, line 443 beforeFind(mapper, id, opts) Lifecycle method method called by find. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes find to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by find. Parameters: Name Type Description mapper Object The mapper argument passed to find. id string | number The id argument passed to find. opts Object The opts argument passed to find. Properties: Name Type Description opts.op string beforeFind Source: node_modules/js-data-adapter/src/index.js, line 461 beforeFindAll(mapper, query, opts) Lifecycle method method called by findAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes findAll to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by findAll. Parameters: Name Type Description mapper Object The mapper argument passed to findAll. query Object The query argument passed to findAll. opts Object The opts argument passed to findAll. Properties: Name Type Description opts.op string beforeFindAll Source: node_modules/js-data-adapter/src/index.js, line 479 beforeSum(mapper, query, opts) Lifecycle method method called by sum. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes sum to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by sum. Parameters: Name Type Description mapper Object The mapper argument passed to sum. query Object The query argument passed to sum. opts Object The opts argument passed to sum. Properties: Name Type Description opts.op string beforeSum Source: node_modules/js-data-adapter/src/index.js, line 497 beforeUpdate(mapper, id, props, opts) Lifecycle method method called by update. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes update to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by update. Parameters: Name Type Description mapper Object The mapper argument passed to update. id string | number The id argument passed to update. props Object The props argument passed to update. opts Object The opts argument passed to update. Properties: Name Type Description opts.op string beforeUpdate Source: node_modules/js-data-adapter/src/index.js, line 515 beforeUpdateAll(mapper, props, query, opts) Lifecycle method method called by updateAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateAll to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateAll. Parameters: Name Type Description mapper Object The mapper argument passed to updateAll. props Object The props argument passed to updateAll. query Object The query argument passed to updateAll. opts Object The opts argument passed to updateAll. Properties: Name Type Description opts.op string beforeUpdateAll Source: node_modules/js-data-adapter/src/index.js, line 536 beforeUpdateMany(mapper, props, opts) Lifecycle method method called by updateMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateMany to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateMany. Parameters: Name Type Description mapper Object The mapper argument passed to updateMany. props Array.&lt;Object&gt; The props argument passed to updateMany. opts Object The opts argument passed to updateMany. Properties: Name Type Description opts.op string beforeUpdateMany Source: node_modules/js-data-adapter/src/index.js, line 557 count(mapper, query, opts) Retrieve the number of records that match the selection query. Called by Mapper#count. Parameters: Name Type Argument Description mapper Object The mapper. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy string | Array &lt;optional&gt; Sorting criteria. sort string | Array &lt;optional&gt; Same as query.sort. limit number &lt;optional&gt; Limit results. skip number &lt;optional&gt; Offset results. offset number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 587 Returns: Type Promise create(mapper, props, opts) Create a new record. Called by Mapper#create. Parameters: Name Type Argument Description mapper Object The mapper. props Object The record to be created. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 634 Returns: Type Promise createMany(mapper, props, opts) Create multiple records in a single batch. Called by Mapper#createMany. Parameters: Name Type Argument Description mapper Object The mapper. props Object The records to be created. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 677 Returns: Type Promise dbg() Shortcut for #log('debug'[, arg1[, arg2[, argn]]]). Source: node_modules/js-data-adapter/src/index.js, line 577 destroy(mapper, id, opts) Destroy the record with the given primary key. Called by Mapper#destroy. Parameters: Name Type Argument Description mapper Object The mapper. id string | number Primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 723 Returns: Type Promise destroyAll(mapper, query, opts) Destroy the records that match the selection query. Called by Mapper#destroyAll. Parameters: Name Type Argument Description mapper Object the mapper. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy string | Array &lt;optional&gt; Sorting criteria. sort string | Array &lt;optional&gt; Same as query.sort. limit number &lt;optional&gt; Limit results. skip number &lt;optional&gt; Offset results. offset number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 762 Returns: Type Promise find(mapper, id, opts) Retrieve the record with the given primary key. Called by Mapper#find. Parameters: Name Type Argument Description mapper Object The mapper. id string | number Primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to eager load. Source: node_modules/js-data-adapter/src/index.js, line 1075 Returns: Type Promise findAll(mapper, query, opts) Retrieve the records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy string | Array &lt;optional&gt; Sorting criteria. sort string | Array &lt;optional&gt; Same as query.sort. limit number &lt;optional&gt; Limit results. skip number &lt;optional&gt; Offset results. offset number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. with Array.&lt;string&gt; &lt;optional&gt; [] Relations to eager load. Source: node_modules/js-data-adapter/src/index.js, line 1143 Returns: Type Promise getOpt(opt, opts) Resolve the value of the specified option based on the given options and this adapter's settings. Override with care. Parameters: Name Type Argument Description opt string The name of the option. opts Object &lt;optional&gt; Configuration options. Source: node_modules/js-data-adapter/src/index.js, line 1225 Returns: The value of the specified option. Type * loadBelongsTo() Load a belongsTo relationship. Override with care. Source: node_modules/js-data-adapter/src/index.js, line 1033 Returns: Type Promise loadHasMany() Load a hasMany relationship. Override with care. Source: node_modules/js-data-adapter/src/index.js, line 854 Returns: Type Promise loadHasOne() Load a hasOne relationship. Override with care. Source: node_modules/js-data-adapter/src/index.js, line 997 Returns: Type Promise log(level, values) Logging utility method. Override this method if you want to send log messages to something other than the console. Parameters: Name Type Argument Description level string Log level. values * &lt;repeatable&gt; Values to log. Source: node_modules/js-data-adapter/src/index.js, line 1240 makeBelongsToForeignKey() Return the foreignKey from the given record for the provided relationship. Override with care. Source: node_modules/js-data-adapter/src/index.js, line 1020 Returns: Type * makeHasManyForeignKey() Return the foreignKey from the given record for the provided relationship. There may be reasons why you may want to override this method, like when the id of the parent doesn't exactly match up to the key on the child. Override with care. Source: node_modules/js-data-adapter/src/index.js, line 808 Returns: Type * makeHasManyForeignKeys() Return the foreignKeys from the given record for the provided relationship. Override with care. Source: node_modules/js-data-adapter/src/index.js, line 841 Returns: Type * makeHasManyLocalKeys() Return the localKeys from the given record for the provided relationship. Override with care. Source: node_modules/js-data-adapter/src/index.js, line 824 Returns: Type * respond(response, opts) Parameters: Name Type Description response Object Response object. opts Object Configuration options. return {Object} If opts.raw == true then return response, else return response.data. Source: node_modules/js-data-adapter/src/index.js, line 1316 sum(mapper, field, query, opts) Retrieve sum of the specified field of the records that match the selection query. Called by Mapper#sum. Parameters: Name Type Argument Description mapper Object The mapper. field string By to sum. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy string | Array &lt;optional&gt; Sorting criteria. sort string | Array &lt;optional&gt; Same as query.sort. limit number &lt;optional&gt; Limit results. skip number &lt;optional&gt; Offset results. offset number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 1265 Returns: Type Promise update(mapper, id, props, opts) Apply the given update to the record with the specified primary key. Called by Mapper#update. Parameters: Name Type Argument Description mapper Object The mapper. id string | number The primary key of the record to be updated. props Object The update to apply to the record. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 1328 Returns: Type Promise updateAll(mapper, props, query, opts) Apply the given update to all records that match the selection query. Called by Mapper#updateAll. Parameters: Name Type Argument Description mapper Object The mapper. props Object The update to apply to the selected records. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy string | Array &lt;optional&gt; Sorting criteria. sort string | Array &lt;optional&gt; Same as query.sort. limit number &lt;optional&gt; Limit results. skip number &lt;optional&gt; Offset results. offset number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 1372 Returns: Type Promise updateMany(mapper, records, opts) Update the given records in a single batch. Called by Mapper#updateMany. Parameters: Name Type Argument Description mapper Object The mapper. records Array.&lt;Object&gt; The records to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false Whether to return a more detailed response object. Source: node_modules/js-data-adapter/src/index.js, line 1424 Returns: Type Promise  Search results Close Back to js-data.io "},"HttpAdapter.html":{"id":"HttpAdapter.html","title":"Class: HttpAdapter","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Class: HttpAdapter HttpAdapter new HttpAdapter(opts) HttpAdapter class. Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description basePath string &lt;optional&gt; '' TODO debug boolean &lt;optional&gt; false TODO forceTrailingSlash boolean &lt;optional&gt; false TODO http Object &lt;optional&gt; axios TODO httpConfig Object &lt;optional&gt; {} TODO suffix string &lt;optional&gt; '' TODO useFetch boolean &lt;optional&gt; false TODO Source: src/index.js, line 124 Members &lt;static&gt; version :Object Details of the current version of the js-data-http module. Type: Object Properties: Name Type Description version.full string The full semver value. version.major number The major version number. version.minor number The minor version number. version.patch number The patch version number. version.alpha string | boolean The alpha version value, otherwise false if the current version is not alpha. version.beta string | boolean The beta version value, otherwise false if the current version is not beta. Source: src/index.js, line 1218 basePath :string Type: string Source: src/index.js, line 85 forceTrailingSlash :boolean Type: boolean Default Value: false Source: src/index.js, line 91 http :function Type: function Source: src/index.js, line 98 httpConfig :Object Type: Object Source: src/index.js, line 104 suffix :string Type: string Source: src/index.js, line 110 useFetch :boolean Type: boolean Default Value: false Source: src/index.js, line 116 Methods &lt;static&gt; addAction(name, opts) Add an Http actions to a mapper. Parameters: Name Type Argument Description name string Name of the new action. opts Object &lt;optional&gt; Action configuration Properties Name Type Argument Description adapter string &lt;optional&gt; pathname string &lt;optional&gt; request function &lt;optional&gt; response function &lt;optional&gt; responseError function &lt;optional&gt; Source: src/index.js, line 1080 Returns: Decoration function, which should be passed the mapper to decorate when invoked. Type function &lt;static&gt; addActions(opts) Add multiple Http actions to a mapper. See HttpAdapter.addAction for action configuration options. Parameters: Name Type Description opts Object.&lt;string, Object&gt; Object where the key is an action name and the value is the configuration for the action. Source: src/index.js, line 1149 Returns: Decoration function, which should be passed the mapper to decorate when invoked. Type function &lt;static&gt; extend(instanceProps, classProps) Alternative to ES6 class syntax for extending HttpAdapter. ES6: class MyHttpAdapter extends HttpAdapter { deserialize (Model, data, opts) { const data = super.deserialize(Model, data, opts) data.foo = 'bar' return data } }ES5: var instanceProps = { // override deserialize deserialize: function (Model, data, opts) { var Ctor = this.constructor var superDeserialize = (Ctor.__super__ || Object.getPrototypeOf(Ctor)).deserialize // call the super deserialize var data = superDeserialize(Model, data, opts) data.foo = 'bar' return data }, say: function () { return 'hi' } } var classProps = { yell: function () { return 'HI' } } var MyHttpAdapter = HttpAdapter.extend(instanceProps, classProps) var adapter = new MyHttpAdapter() adapter.say() // &quot;hi&quot; MyHttpAdapter.yell() // &quot;HI&quot; Parameters: Name Type Argument Description instanceProps Object &lt;optional&gt; Properties that will be added to the prototype of the subclass. classProps Object &lt;optional&gt; Properties that will be added as static properties to the subclass itself. Source: src/index.js, line 1170 Returns: Subclass of HttpAdapter. Type Object afterDEL(url, config, opts, response) Parameters: Name Type Description url string config Object opts Object response Object Source: src/index.js, line 160 afterGET(url, config, opts, response) Parameters: Name Type Description url string config Object opts Object response Object Source: src/index.js, line 170 afterHTTP(config, opts, response) Parameters: Name Type Description config Object opts Object response Object Source: src/index.js, line 180 afterPOST(url, data, config, opts, response) Parameters: Name Type Description url string data Object config Object opts Object response Object Source: src/index.js, line 189 afterPUT(url, data, config, opts, response) Parameters: Name Type Description url string data Object config Object opts Object response Object Source: src/index.js, line 200 beforeDEL(url, config, opts) Parameters: Name Type Description url Object config Object opts Object Source: src/index.js, line 211 beforeGET(url, config, opts) Parameters: Name Type Description url Object config Object opts Object Source: src/index.js, line 220 beforeHTTP(config, opts) Parameters: Name Type Description config Object opts Object Source: src/index.js, line 229 beforePOST(url, data, config, opts) Parameters: Name Type Description url Object data Object config Object opts Object Source: src/index.js, line 237 beforePUT(url, data, config, opts) Parameters: Name Type Description url Object data Object config Object opts Object Source: src/index.js, line 247 count(mapper, query, opts) Retrieve the number of records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 376 Returns: Type Promise create(mapper, props, opts) Create a new the record from the provided props. Parameters: Name Type Argument Description mapper Object The mapper. props Object Properties to send as the payload. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 401 Returns: Type Promise createMany(mapper, props, opts) Create multiple new records in batch. Parameters: Name Type Argument Description mapper Object The mapper. props Array Array of property objects to send as the payload. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 423 Returns: Type Promise DEL(url, config, opts) Make an Http request to url according to the configuration in config. Parameters: Name Type Argument Description url string Url for the request. config Object &lt;optional&gt; Http configuration that will be passed to HttpAdapter#HTTP. opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 445 Returns: Type Promise deserialize(mapper, response, opts) Transform the server response object into the payload that will be returned to JSData. Parameters: Name Type Description mapper Object The mapper used for the operation. response Object Response object from HttpAdapter#HTTP. opts Object Configuration options. Source: src/index.js, line 482 Returns: Deserialized data. Type Object | Array destroy(mapper, id, opts) Destroy the record with the given primary key. Parameters: Name Type Argument Description mapper Object The mapper. id string | number Primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 507 Returns: Type Promise destroyAll(mapper, query, opts) Destroy the records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 529 Returns: Type Promise error(args) Log an error. Parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Arguments to log. Source: src/index.js, line 553 fetch(config, opts) Make an Http request using window.fetch. Parameters: Name Type Argument Description config Object Request configuration. Properties Name Type Description data Object Payload for the request. method string Http method for the request. headers Object Headers for the request. params Object Querystring for the request. url string Url for the request. opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 566 find(mapper, id, opts) Retrieve the record with the given primary key. Parameters: Name Type Argument Description mapper Object The mapper. id string | number Primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 602 Returns: Type Promise findAll(mapper, query, opts) Retrieve the records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 624 Returns: Type Promise GET(url, config, opts) TODO Parameters: Name Type Argument Description url string The url for the request. config Object Request configuration options. opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 648 Returns: Type Promise getEndpoint(mapper, id, opts) Parameters: Name Type Description mapper Object TODO id * TODO opts boolean TODO Source: src/index.js, line 684 Returns: Full path. Type string getPath(method, mapper, id, opts) Parameters: Name Type Argument Description method string TODO mapper Object TODO id string | number &lt;nullable&gt; TODO opts Object Configuration options. Source: src/index.js, line 740 HTTP(config, opts) Make an Http request. Parameters: Name Type Argument Description config Object Request configuration options. opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 780 Returns: Type Promise POST(url, data, config, opts) TODO Parameters: Name Type Argument Description url * TODO data Object TODO config Object TODO opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 844 Returns: Type Promise PUT(url, data, config, opts) TODO Parameters: Name Type Argument Description url * TODO data Object TODO config Object TODO opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 882 Returns: Type Promise queryTransform(mapper, params, opts) TODO Parameters: Name Type Description mapper Object TODO params * TODO opts * TODO Source: src/index.js, line 920 Returns: Transformed params. Type * responseError(err, config, opts) Error handler invoked when the promise returned by HttpAdapter#http is rejected. Default implementation is to just return the error wrapped in a rejected Promise, aka rethrow the error. HttpAdapter#http is called by HttpAdapter#HTTP. Parameters: Name Type Description err * The error that HttpAdapter#http rejected with. config Object The config argument that was passed to HttpAdapter#HTTP. opts * The opts argument that was passed to HttpAdapter#HTTP. Source: src/index.js, line 941 Returns: Type Promise serialize(mapper, data, opts) TODO Parameters: Name Type Description mapper Object TODO data Object TODO opts * TODO Source: src/index.js, line 958 Returns: Serialized data. Type * sum(mapper, field, query, opts) Retrieve the sum of the field of the records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. field string The field to sum. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 979 Returns: Type Promise update(mapper, id, props, opts) TODO Parameters: Name Type Argument Description mapper Object TODO id * TODO props * TODO opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 1008 Returns: Type Promise updateAll(mapper, props, query, opts) TODO Parameters: Name Type Argument Description mapper Object TODO props Object TODO query Object TODO opts Object &lt;optional&gt; Configuration options. Source: src/index.js, line 1029 Returns: Type Promise updateMany(mapper, records, opts) Update multiple records in batch. HttpAdapter#beforeUpdateMany will be called before calling HttpAdapter#PUT. HttpAdapter#afterUpdateMany will be called after calling HttpAdapter#PUT. Parameters: Name Type Argument Description mapper Object The mapper. records Array Array of property objects to send as the payload. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params string &lt;optional&gt; TODO suffix string &lt;optional&gt; HttpAdapter#suffix TODO Source: src/index.js, line 1052 Returns: Type Promise  Search results Close Back to js-data.io "},"module-js-data-http.html":{"id":"module-js-data-http.html","title":"Module: js-data-http","body":" js-data-http Modules js-data-http Classes AdapterHttpAdapter Global Global Module: js-data-http Registered as js-data-http in NPM and Bower. The build of js-data-http that works on Node.js is registered in NPM as js-data-http-node. The build of js-data-http that does not bundle axios is registered in NPM and Bower as js-data-fetch. Script tag: window.HttpAdapterCommonJS: var HttpAdapter = require('js-data-http')ES6 Modules: import HttpAdapter from 'js-data-http'AMD: define('myApp', ['js-data-http'], function (HttpAdapter) { ... }) Source: src/index.js, line 1234  Search results Close Back to js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
