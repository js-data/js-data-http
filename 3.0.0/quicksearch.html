<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"node_modules_js-data-adapter_src_index.js.html":{"id":"node_modules_js-data-adapter_src_index.js.html","title":"Source: node_modules/js-data-adapter/src/index.js","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Source: node_modules/js-data-adapter/src/index.js import { Component, utils } from 'js-data' export const noop = function (...args) { const opts = args[args.length - 1] this.dbg(opts.op, ...args) return utils.resolve() } export const noop2 = function (...args) { const opts = args[args.length - 2] this.dbg(opts.op, ...args) return utils.resolve() } export const unique = function (array) { const seen = {} const final = [] array.forEach(function (item) { if (item in seen) { return } final.push(item) seen[item] = 0 }) return final } export const withoutRelations = function (mapper, props, opts) { opts || (opts = {}) opts.with || (opts.with = []) const relationFields = mapper.relationFields || [] const toStrip = relationFields.filter((value) =&gt; opts.with.indexOf(value) === -1) return utils.omit(props, toStrip) } export const reserved = [ 'orderBy', 'sort', 'limit', 'offset', 'skip', 'where' ] /** * Response object used when `raw` is `true`. May contain other fields in * addition to `data`. * * @class Response */ export function Response (data, meta, op) { meta || (meta = {}) /** * Response data. * * @name Response#data * @type {*} */ this.data = data utils.fillIn(this, meta) /** * The operation for which the response was created. * * @name Response#op * @type {string} */ this.op = op } const DEFAULTS = { /** * Whether to log debugging information. * * @name Adapter#debug * @type {boolean} * @default false */ debug: false, /** * Whether to return a more detailed response object. * * @name Adapter#raw * @type {boolean} * @default false */ raw: false } /** * Abstract class meant to be extended by adapters. * * @class Adapter * @abstract * @extends Component * @param {Object} [opts] Configuration opts. * @param {boolean} [opts.debug=false] Whether to log debugging information. * @param {boolean} [opts.raw=false] Whether to return a more detailed response * object. */ export function Adapter (opts) { utils.classCallCheck(this, Adapter) Component.call(this, opts) opts || (opts = {}) utils.fillIn(opts, DEFAULTS) utils.fillIn(this, opts) } Component.extend({ constructor: Adapter, /** * Lifecycle method method called by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the count. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * @name Adapter#afterCount * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @property {string} opts.op `afterCount` * @param {Object|Response} response Count or {@link Response}, depending on the value of `opts.raw`. */ afterCount: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the created record. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * @name Adapter#afterCreate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @property {string} opts.op `afterCreate` * @param {Object|Response} response Created record or {@link Response}, depending on the value of `opts.raw`. */ afterCreate: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the created records. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * @name Adapter#afterCreate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object[]} props The `props` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @property {string} opts.op `afterCreateMany` * @param {Object[]|Response} response Created records or {@link Response}, depending on the value of `opts.raw`. */ afterCreateMany: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be `undefined`. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * @name Adapter#afterDestroy * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @property {string} opts.op `afterDestroy` * @param {undefined|Response} response `undefined` or {@link Response}, depending on the value of `opts.raw`. */ afterDestroy: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be `undefined`. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * @name Adapter#afterDestroyAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @property {string} opts.op `afterDestroyAll` * @param {undefined|Response} response `undefined` or {@link Response}, depending on the value of `opts.raw`. */ afterDestroyAll: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the found record, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * @name Adapter#afterFind * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @property {string} opts.op `afterFind` * @param {Object|Response} response The found record or {@link Response}, depending on the value of `opts.raw`. */ afterFind: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the found records, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * @name Adapter#afterFindAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @property {string} opts.op `afterFindAll` * @param {Object[]|Response} response The found records or {@link Response}, depending on the value of `opts.raw`. */ afterFindAll: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the sum. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * @name Adapter#afterSum * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {string} field The `field` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @property {string} opts.op `afterSum` * @param {Object|Response} response Count or {@link Response}, depending on the value of `opts.raw`. */ afterSum: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the updated record. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * @name Adapter#afterUpdate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @property {string} opts.op `afterUpdate` * @param {Object|Response} response The updated record or {@link Response}, depending on the value of `opts.raw`. */ afterUpdate: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the updated records, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * @name Adapter#afterUpdateAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @property {string} opts.op `afterUpdateAll` * @param {Object[]|Response} response The updated records or {@link Response}, depending on the value of `opts.raw`. */ afterUpdateAll: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * If `opts.raw` is `true` then `response` will be a detailed response object, otherwise `response` will be the updated records, if any. * * `response` may be modified. You can also re-assign `response` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * @name Adapter#afterUpdateMany * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object[]} records The `records` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @property {string} opts.op `afterUpdateMany` * @param {Object[]|Response} response The updated records or {@link Response}, depending on the value of `opts.raw`. */ afterUpdateMany: noop2, /** * Lifecycle method method called by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * * @name Adapter#beforeCount * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#count__anchor&quot;&gt;count&lt;/a&gt;. * @property {string} opts.op `beforeCount` */ beforeCount: noop, /** * Lifecycle method method called by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * * @name Adapter#beforeCreate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#create__anchor&quot;&gt;create&lt;/a&gt;. * @property {string} opts.op `beforeCreate` */ beforeCreate: noop, /** * Lifecycle method method called by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * * @name Adapter#beforeCreateMany * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object[]} props The `props` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#createMany__anchor&quot;&gt;createMany&lt;/a&gt;. * @property {string} opts.op `beforeCreateMany` */ beforeCreateMany: noop, /** * Lifecycle method method called by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * * @name Adapter#beforeDestroy * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroy__anchor&quot;&gt;destroy&lt;/a&gt;. * @property {string} opts.op `beforeDestroy` */ beforeDestroy: noop, /** * Lifecycle method method called by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * * @name Adapter#beforeDestroyAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#destroyAll__anchor&quot;&gt;destroyAll&lt;/a&gt;. * @property {string} opts.op `beforeDestroyAll` */ beforeDestroyAll: noop, /** * Lifecycle method method called by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * * @name Adapter#beforeFind * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#find__anchor&quot;&gt;find&lt;/a&gt;. * @property {string} opts.op `beforeFind` */ beforeFind: noop, /** * Lifecycle method method called by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * * @name Adapter#beforeFindAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#findAll__anchor&quot;&gt;findAll&lt;/a&gt;. * @property {string} opts.op `beforeFindAll` */ beforeFindAll: noop, /** * Lifecycle method method called by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt; to wait for the Promise to resolve before continuing. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * * @name Adapter#beforeSum * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#sum__anchor&quot;&gt;sum&lt;/a&gt;. * @property {string} opts.op `beforeSum` */ beforeSum: noop, /** * Lifecycle method method called by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * * @name Adapter#beforeUpdate * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {(string|number)} id The `id` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#update__anchor&quot;&gt;update&lt;/a&gt;. * @property {string} opts.op `beforeUpdate` */ beforeUpdate: noop, /** * Lifecycle method method called by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * * @name Adapter#beforeUpdateAll * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} props The `props` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} query The `query` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateAll__anchor&quot;&gt;updateAll&lt;/a&gt;. * @property {string} opts.op `beforeUpdateAll` */ beforeUpdateAll: noop, /** * Lifecycle method method called by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * Override this method to add custom behavior for this lifecycle hook. * * Returning a Promise causes &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt; to wait for the Promise to resolve before continuing. * * `props` may be modified. You can also re-assign `props` to another value by returning a different value or a Promise that resolves to a different value. * * A thrown error or rejected Promise will bubble up and reject the Promise returned by &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * * @name Adapter#beforeUpdateMany * @method * @param {Object} mapper The `mapper` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object[]} props The `props` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @param {Object} opts The `opts` argument passed to &lt;a href=&quot;#updateMany__anchor&quot;&gt;updateMany&lt;/a&gt;. * @property {string} opts.op `beforeUpdateMany` */ beforeUpdateMany: noop, /** * Retrieve the number of records that match the selection query. Called by * `Mapper#count`. * * @name Adapter#count * @method * @param {Object} mapper The mapper. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ count (mapper, query, opts) { let op query || (query = {}) opts || (opts = {}) // beforeCount lifecycle hook op = opts.op = 'beforeCount' return utils.resolve(this[op](mapper, query, opts)) .then(() =&gt; { // Allow for re-assignment from lifecycle hook op = opts.op = 'count' this.dbg(op, mapper, query, opts) return utils.resolve(this._count(mapper, query, opts)) }) .then((results) =&gt; { let [data, result] = results result || (result = {}) let response = new Response(data, result, op) response = this.respond(response, opts) // afterCount lifecycle hook op = opts.op = 'afterCount' return utils.resolve(this[op](mapper, query, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Create a new record. Called by `Mapper#create`. * * @name Adapter#create * @method * @param {Object} mapper The mapper. * @param {Object} props The record to be created. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ create (mapper, props, opts) { let op props || (props = {}) opts || (opts = {}) // beforeCreate lifecycle hook op = opts.op = 'beforeCreate' return utils.resolve(this[op](mapper, props, opts)) .then((_props) =&gt; { // Allow for re-assignment from lifecycle hook props = _props === undefined ? props : _props props = withoutRelations(mapper, props, opts) op = opts.op = 'create' this.dbg(op, mapper, props, opts) return utils.resolve(this._create(mapper, props, opts)) }) .then((results) =&gt; { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'create') response.created = data ? 1 : 0 response = this.respond(response, opts) // afterCreate lifecycle hook op = opts.op = 'afterCreate' return utils.resolve(this[op](mapper, props, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Create multiple records in a single batch. Called by `Mapper#createMany`. * * @name Adapter#createMany * @method * @param {Object} mapper The mapper. * @param {Object} props The records to be created. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ createMany (mapper, props, opts) { let op props || (props = {}) opts || (opts = {}) // beforeCreateMany lifecycle hook op = opts.op = 'beforeCreateMany' return utils.resolve(this[op](mapper, props, opts)) .then((_props) =&gt; { // Allow for re-assignment from lifecycle hook props = _props === undefined ? props : _props props = props.map((record) =&gt; withoutRelations(mapper, record, opts)) op = opts.op = 'createMany' this.dbg(op, mapper, props, opts) return utils.resolve(this._createMany(mapper, props, opts)) }) .then((results) =&gt; { let [data, result] = results data || (data = []) result || (result = {}) let response = new Response(data, result, 'createMany') response.created = data.length response = this.respond(response, opts) // afterCreateMany lifecycle hook op = opts.op = 'afterCreateMany' return utils.resolve(this[op](mapper, props, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Destroy the record with the given primary key. Called by * `Mapper#destroy`. * * @name Adapter#destroy * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to destroy. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ destroy (mapper, id, opts) { let op opts || (opts = {}) // beforeDestroy lifecycle hook op = opts.op = 'beforeDestroy' return utils.resolve(this[op](mapper, id, opts)) .then(() =&gt; { op = opts.op = 'destroy' this.dbg(op, mapper, id, opts) return utils.resolve(this._destroy(mapper, id, opts)) }) .then((results) =&gt; { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'destroy') response = this.respond(response, opts) // afterDestroy lifecycle hook op = opts.op = 'afterDestroy' return utils.resolve(this[op](mapper, id, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Destroy the records that match the selection query. Called by * `Mapper#destroyAll`. * * @name Adapter#destroyAll * @method * @param {Object} mapper the mapper. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ destroyAll (mapper, query, opts) { let op query || (query = {}) opts || (opts = {}) // beforeDestroyAll lifecycle hook op = opts.op = 'beforeDestroyAll' return utils.resolve(this[op](mapper, query, opts)) .then(() =&gt; { op = opts.op = 'destroyAll' this.dbg(op, mapper, query, opts) return utils.resolve(this._destroyAll(mapper, query, opts)) }) .then((results) =&gt; { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'destroyAll') response = this.respond(response, opts) // afterDestroyAll lifecycle hook op = opts.op = 'afterDestroyAll' return utils.resolve(this[op](mapper, query, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Load a belongsTo relationship. * * Override with care. * * @name Adapter#loadBelongsTo * @method * @return {Promise} */ loadBelongsTo (mapper, def, records, __opts) { const relationDef = def.getRelation() if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { const record = records return this.find(relationDef, this.makeBelongsToForeignKey(mapper, def, record), __opts) .then((relatedItem) =&gt; { def.setLocalField(record, relatedItem) }) } else { const keys = records .map((record) =&gt; this.makeBelongsToForeignKey(mapper, def, record)) .filter((key) =&gt; key) return this.findAll(relationDef, { where: { [relationDef.idAttribute]: { 'in': keys } } }, __opts).then((relatedItems) =&gt; { records.forEach((record) =&gt; { relatedItems.forEach((relatedItem) =&gt; { if (relatedItem[relationDef.idAttribute] === record[def.foreignKey]) { def.setLocalField(record, relatedItem) } }) }) }) } }, /** * Retrieve the record with the given primary key. Called by `Mapper#find`. * * @name Adapter#find * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to retrieve. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @param {string[]} [opts.with=[]] Relations to eager load. * @return {Promise} */ find (mapper, id, opts) { let op opts || (opts = {}) opts.with || (opts.with = []) // beforeFind lifecycle hook op = opts.op = 'beforeFind' return utils.resolve(this[op](mapper, id, opts)) .then(() =&gt; { op = opts.op = 'find' this.dbg(op, mapper, id, opts) return utils.resolve(this._find(mapper, id, opts)) }) .then((results) =&gt; this.loadRelationsFor(mapper, results, opts)) .then(([record, meta]) =&gt; { let response = new Response(record, meta, 'find') response.found = record ? 1 : 0 response = this.respond(response, opts) // afterFind lifecycle hook op = opts.op = 'afterFind' return utils.resolve(this[op](mapper, id, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Retrieve the records that match the selection query. * * @name Adapter#findAll * @method * @param {Object} mapper The mapper. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @param {string[]} [opts.with=[]] Relations to eager load. * @return {Promise} */ findAll (mapper, query, opts) { let op opts || (opts = {}) opts.with || (opts.with = []) const activeWith = opts._activeWith if (utils.isObject(activeWith)) { const activeQuery = activeWith.query || {} if (activeWith.replace) { query = activeQuery } else { utils.deepFillIn(query, activeQuery) } } // beforeFindAll lifecycle hook op = opts.op = 'beforeFindAll' return utils.resolve(this[op](mapper, query, opts)) .then(() =&gt; { op = opts.op = 'findAll' this.dbg(op, mapper, query, opts) return utils.resolve(this._findAll(mapper, query, opts)) }) .then((results) =&gt; this.loadRelationsFor(mapper, results, opts)) .then(([records, meta]) =&gt; { let response = new Response(records, meta, 'findAll') response.found = records.length response = this.respond(response, opts) // afterFindAll lifecycle hook op = opts.op = 'afterFindAll' return utils.resolve(this[op](mapper, query, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, loadRelationsFor (mapper, results, opts) { const [records] = results const tasks = [] if (records) { utils.forEachRelation(mapper, opts, (def, __opts) =&gt; { let task if (def.foreignKey &amp;&amp; (def.type === 'hasOne' || def.type === 'hasMany')) { if (def.type === 'hasOne') { task = this.loadHasOne(mapper, def, records, __opts) } else { task = this.loadHasMany(mapper, def, records, __opts) } } else if (def.type === 'hasMany' &amp;&amp; def.localKeys) { task = this.loadHasManyLocalKeys(mapper, def, records, __opts) } else if (def.type === 'hasMany' &amp;&amp; def.foreignKeys) { task = this.loadHasManyForeignKeys(mapper, def, records, __opts) } else if (def.type === 'belongsTo') { task = this.loadBelongsTo(mapper, def, records, __opts) } if (task) { tasks.push(task) } }) } return utils.Promise.all(tasks) .then(() =&gt; results) }, /** * Resolve the value of the specified option based on the given options and * this adapter's settings. Override with care. * * @name Adapter#getOpt * @method * @param {string} opt The name of the option. * @param {Object} [opts] Configuration options. * @return {*} The value of the specified option. */ getOpt (opt, opts) { opts || (opts = {}) return opts[opt] === undefined ? utils.plainCopy(this[opt]) : utils.plainCopy(opts[opt]) }, /** * Load a hasMany relationship. * * Override with care. * * @name Adapter#loadHasMany * @method * @return {Promise} */ loadHasMany (mapper, def, records, __opts) { let singular = false if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { singular = true records = [records] } const IDs = records.map((record) =&gt; this.makeHasManyForeignKey(mapper, def, record)) const query = { where: {} } const criteria = query.where[def.foreignKey] = {} if (singular) { // more efficient query when we only have one record criteria['=='] = IDs[0] } else { criteria['in'] = IDs.filter((id) =&gt; id) } return this.findAll(def.getRelation(), query, __opts).then((relatedItems) =&gt; { records.forEach((record) =&gt; { let attached = [] // avoid unneccesary iteration when we only have one record if (singular) { attached = relatedItems } else { relatedItems.forEach((relatedItem) =&gt; { if (utils.get(relatedItem, def.foreignKey) === record[mapper.idAttribute]) { attached.push(relatedItem) } }) } def.setLocalField(record, attached) }) }) }, loadHasManyLocalKeys (mapper, def, records, __opts) { let record const relatedMapper = def.getRelation() if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { record = records } if (record) { return this.findAll(relatedMapper, { where: { [relatedMapper.idAttribute]: { 'in': this.makeHasManyLocalKeys(mapper, def, record) } } }, __opts).then((relatedItems) =&gt; { def.setLocalField(record, relatedItems) }) } else { let localKeys = [] records.forEach((record) =&gt; { localKeys = localKeys.concat(this.makeHasManyLocalKeys(mapper, def, record)) }) return this.findAll(relatedMapper, { where: { [relatedMapper.idAttribute]: { 'in': unique(localKeys).filter((x) =&gt; x) } } }, __opts).then((relatedItems) =&gt; { records.forEach((item) =&gt; { let attached = [] let itemKeys = utils.get(item, def.localKeys) || [] itemKeys = utils.isArray(itemKeys) ? itemKeys : Object.keys(itemKeys) relatedItems.forEach((relatedItem) =&gt; { if (itemKeys &amp;&amp; itemKeys.indexOf(relatedItem[relatedMapper.idAttribute]) !== -1) { attached.push(relatedItem) } }) def.setLocalField(item, attached) }) return relatedItems }) } }, loadHasManyForeignKeys (mapper, def, records, __opts) { const relatedMapper = def.getRelation() const idAttribute = mapper.idAttribute let record if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { record = records } if (record) { return this.findAll(def.getRelation(), { where: { [def.foreignKeys]: { 'contains': this.makeHasManyForeignKeys(mapper, def, record) } } }, __opts).then((relatedItems) =&gt; { def.setLocalField(record, relatedItems) }) } else { return this.findAll(relatedMapper, { where: { [def.foreignKeys]: { 'isectNotEmpty': records.map((record) =&gt; this.makeHasManyForeignKeys(mapper, def, record)) } } }, __opts).then((relatedItems) =&gt; { const foreignKeysField = def.foreignKeys records.forEach((record) =&gt; { const _relatedItems = [] const id = utils.get(record, idAttribute) relatedItems.forEach((relatedItem) =&gt; { const foreignKeys = utils.get(relatedItems, foreignKeysField) || [] if (foreignKeys.indexOf(id) !== -1) { _relatedItems.push(relatedItem) } }) def.setLocalField(record, _relatedItems) }) }) } }, /** * Load a hasOne relationship. * * Override with care. * * @name Adapter#loadHasOne * @method * @return {Promise} */ loadHasOne (mapper, def, records, __opts) { if (utils.isObject(records) &amp;&amp; !utils.isArray(records)) { records = [records] } return this.loadHasMany(mapper, def, records, __opts).then(() =&gt; { records.forEach((record) =&gt; { const relatedData = def.getLocalField(record) if (utils.isArray(relatedData) &amp;&amp; relatedData.length) { def.setLocalField(record, relatedData[0]) } }) }) }, /** * Return the foreignKey from the given record for the provided relationship. * * There may be reasons why you may want to override this method, like when * the id of the parent doesn't exactly match up to the key on the child. * * Override with care. * * @name Adapter#makeHasManyForeignKey * @method * @return {*} */ makeHasManyForeignKey (mapper, def, record) { return def.getForeignKey(record) }, /** * Return the localKeys from the given record for the provided relationship. * * Override with care. * * @name Adapter#makeHasManyLocalKeys * @method * @return {*} */ makeHasManyLocalKeys (mapper, def, record) { let localKeys = [] let itemKeys = utils.get(record, def.localKeys) || [] itemKeys = utils.isArray(itemKeys) ? itemKeys : Object.keys(itemKeys) localKeys = localKeys.concat(itemKeys) return unique(localKeys).filter((x) =&gt; x) }, /** * Return the foreignKeys from the given record for the provided relationship. * * Override with care. * * @name Adapter#makeHasManyForeignKeys * @method * @return {*} */ makeHasManyForeignKeys (mapper, def, record) { return utils.get(record, mapper.idAttribute) }, /** * Return the foreignKey from the given record for the provided relationship. * * Override with care. * * @name Adapter#makeBelongsToForeignKey * @method * @return {*} */ makeBelongsToForeignKey (mapper, def, record) { return def.getForeignKey(record) }, /** * Retrieve sum of the specified field of the records that match the selection * query. Called by `Mapper#sum`. * * @name Adapter#sum * @method * @param {Object} mapper The mapper. * @param {string} field By to sum. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ sum (mapper, field, query, opts) { let op if (!utils.isString(field)) { throw new Error('field must be a string!') } query || (query = {}) opts || (opts = {}) // beforeSum lifecycle hook op = opts.op = 'beforeSum' return utils.resolve(this[op](mapper, field, query, opts)) .then(() =&gt; { // Allow for re-assignment from lifecycle hook op = opts.op = 'sum' this.dbg(op, mapper, field, query, opts) return utils.resolve(this._sum(mapper, field, query, opts)) }) .then((results) =&gt; { let [data, result] = results result || (result = {}) let response = new Response(data, result, op) response = this.respond(response, opts) // afterSum lifecycle hook op = opts.op = 'afterSum' return utils.resolve(this[op](mapper, field, query, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * @name Adapter#respond * @method * @param {Object} response Response object. * @param {Object} opts Configuration options. * return {Object} If `opts.raw == true` then return `response`, else return * `response.data`. */ respond (response, opts) { return this.getOpt('raw', opts) ? response : response.data }, /** * Apply the given update to the record with the specified primary key. Called * by `Mapper#update`. * * @name Adapter#update * @method * @param {Object} mapper The mapper. * @param {(string|number)} id The primary key of the record to be updated. * @param {Object} props The update to apply to the record. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ update (mapper, id, props, opts) { props || (props = {}) opts || (opts = {}) let op // beforeUpdate lifecycle hook op = opts.op = 'beforeUpdate' return utils.resolve(this[op](mapper, id, props, opts)) .then((_props) =&gt; { // Allow for re-assignment from lifecycle hook props = _props === undefined ? props : _props props = withoutRelations(mapper, props, opts) op = opts.op = 'update' this.dbg(op, mapper, id, props, opts) return utils.resolve(this._update(mapper, id, props, opts)) }) .then((results) =&gt; { let [data, result] = results result || (result = {}) let response = new Response(data, result, 'update') response.updated = data ? 1 : 0 response = this.respond(response, opts) // afterUpdate lifecycle hook op = opts.op = 'afterUpdate' return utils.resolve(this[op](mapper, id, props, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Apply the given update to all records that match the selection query. * Called by `Mapper#updateAll`. * * @name Adapter#updateAll * @method * @param {Object} mapper The mapper. * @param {Object} props The update to apply to the selected records. * @param {Object} [query] Selection query. * @param {Object} [query.where] Filtering criteria. * @param {string|Array} [query.orderBy] Sorting criteria. * @param {string|Array} [query.sort] Same as `query.sort`. * @param {number} [query.limit] Limit results. * @param {number} [query.skip] Offset results. * @param {number} [query.offset] Same as `query.skip`. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ updateAll (mapper, props, query, opts) { props || (props = {}) query || (query = {}) opts || (opts = {}) let op // beforeUpdateAll lifecycle hook op = opts.op = 'beforeUpdateAll' return utils.resolve(this[op](mapper, props, query, opts)) .then((_props) =&gt; { // Allow for re-assignment from lifecycle hook props = _props === undefined ? props : _props props = withoutRelations(mapper, props, opts) op = opts.op = 'updateAll' this.dbg(op, mapper, props, query, opts) return utils.resolve(this._updateAll(mapper, props, query, opts)) }) .then((results) =&gt; { let [data, result] = results data || (data = []) result || (result = {}) let response = new Response(data, result, 'updateAll') response.updated = data.length response = this.respond(response, opts) // afterUpdateAll lifecycle hook op = opts.op = 'afterUpdateAll' return utils.resolve(this[op](mapper, props, query, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Update the given records in a single batch. Called by `Mapper#updateMany`. * * @name Adapter#updateMany * @method * @param {Object} mapper The mapper. * @param {Object[]} records The records to update. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] Whether to return a more detailed * response object. * @return {Promise} */ updateMany (mapper, records, opts) { records || (records = []) opts || (opts = {}) let op const idAttribute = mapper.idAttribute records = records.filter((record) =&gt; utils.get(record, idAttribute)) // beforeUpdateMany lifecycle hook op = opts.op = 'beforeUpdateMany' return utils.resolve(this[op](mapper, records, opts)) .then((_records) =&gt; { // Allow for re-assignment from lifecycle hook records = _records === undefined ? records : _records records = records.map((record) =&gt; withoutRelations(mapper, record, opts)) op = opts.op = 'updateMany' this.dbg(op, mapper, records, opts) return utils.resolve(this._updateMany(mapper, records, opts)) }) .then((results) =&gt; { let [data, result] = results data || (data = []) result || (result = {}) let response = new Response(data, result, 'updateMany') response.updated = data.length response = this.respond(response, opts) // afterUpdateMany lifecycle hook op = opts.op = 'afterUpdateMany' return utils.resolve(this[op](mapper, records, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) } }) /** * Create a subclass of this Adapter: * * @example &lt;caption&gt;Adapter.extend&lt;/caption&gt; * // Normally you would do: import {Adapter} from 'js-data' * const JSData = require('js-data@3.0.0-beta.10') * const {Adapter} = JSData * console.log('Using JSData v' + JSData.version.full) * * // Extend the class using ES2015 class syntax. * class CustomAdapterClass extends Adapter { * foo () { return 'bar' } * static beep () { return 'boop' } * } * const customAdapter = new CustomAdapterClass() * console.log(customAdapter.foo()) * console.log(CustomAdapterClass.beep()) * * // Extend the class using alternate method. * const OtherAdapterClass = Adapter.extend({ * foo () { return 'bar' } * }, { * beep () { return 'boop' } * }) * const otherAdapter = new OtherAdapterClass() * console.log(otherAdapter.foo()) * console.log(OtherAdapterClass.beep()) * * // Extend the class, providing a custom constructor. * function AnotherAdapterClass () { * Adapter.call(this) * this.created_at = new Date().getTime() * } * Adapter.extend({ * constructor: AnotherAdapterClass, * foo () { return 'bar' } * }, { * beep () { return 'boop' } * }) * const anotherAdapter = new AnotherAdapterClass() * console.log(anotherAdapter.created_at) * console.log(anotherAdapter.foo()) * console.log(AnotherAdapterClass.beep()) * * @method Adapter.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Adapter class. */  Search results Close api.js-data.io  js-data.io "},"node_modules_js-data_src_Component.js.html":{"id":"node_modules_js-data_src_Component.js.html","title":"Source: node_modules/js-data/src/Component.js","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Source: node_modules/js-data/src/Component.js import utils from './utils' import Settable from './Settable' /** * The base class from which all JSData components inherit some basic * functionality. * * Typically you won't instantiate this class directly, but you may find it * useful as an abstract class for your own components. * * See {@link Component.extend} for an example of using {@link Component} as a * base class. * *```javascript * import {Component} from 'js-data' * ``` * * @class Component * @param {Object} [opts] Configuration options. * @param {boolean} [opts.debug=false] See {@link Component#debug}. * @returns {Component} A new {@link Component} instance. * @since 3.0.0 */ function Component (opts) { Settable.call(this) opts || (opts = {}) /** * Whether to enable debug-level logs for this component. Anything that * extends `Component` inherits this option and the corresponding logging * functionality. * * @example &lt;caption&gt;Component#debug&lt;/caption&gt; * // Normally you would do: import {Component} from 'js-data' * const JSData = require('js-data@3.0.0-rc.4') * const {Component} = JSData * console.log('Using JSData v' + JSData.version.full) * * const component = new Component() * component.log('debug', 'some message') // nothing gets logged * // Display debug logs: * component.debug = true * component.log('debug', 'other message') // this DOES get logged * * @default false * @name Component#debug * @since 3.0.0 * @type {boolean} */ this.debug = opts.hasOwnProperty('debug') ? !!opts.debug : false /** * Event listeners attached to this Component. __Do not modify.__ Use * {@link Component#on} and {@link Component#off} instead. * * @name Component#_listeners * @private * @instance * @since 3.0.0 * @type {Object} */ Object.defineProperty(this, '_listeners', { value: {}, writable: true }) } export default Settable.extend({ constructor: Component }) /** * Create a subclass of this Component: * * @example &lt;caption&gt;Component.extend&lt;/caption&gt; * // Normally you would do: import {Component} from 'js-data' * const JSData = require('js-data@3.0.0-rc.4') * const {Component} = JSData * console.log('Using JSData v' + JSData.version.full) * * // Extend the class using ES2015 class syntax. * class CustomComponentClass extends Component { * foo () { return 'bar' } * static beep () { return 'boop' } * } * const customComponent = new CustomComponentClass() * console.log(customComponent.foo()) * console.log(CustomComponentClass.beep()) * * // Extend the class using alternate method. * const OtherComponentClass = Component.extend({ * foo () { return 'bar' } * }, { * beep () { return 'boop' } * }) * const otherComponent = new OtherComponentClass() * console.log(otherComponent.foo()) * console.log(OtherComponentClass.beep()) * * // Extend the class, providing a custom constructor. * function AnotherComponentClass () { * Component.call(this) * this.created_at = new Date().getTime() * } * Component.extend({ * constructor: AnotherComponentClass, * foo () { return 'bar' } * }, { * beep () { return 'boop' } * }) * const anotherComponent = new AnotherComponentClass() * console.log(anotherComponent.created_at) * console.log(anotherComponent.foo()) * console.log(AnotherComponentClass.beep()) * * @method Component.extend * @param {Object} [props={}] Properties to add to the prototype of the * subclass. * @param {Object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {Object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this Component class. * @since 3.0.0 */ Component.extend = utils.extend /** * Log the provided values at the &quot;debug&quot; level. Debug-level logs are only * logged if {@link Component#debug} is `true`. * * `.dbg(...)` is shorthand for `.log('debug', ...)`. * * @method Component#dbg * @param {...*} [args] Values to log. * @since 3.0.0 */ /** * Log the provided values. By default sends values to `console[level]`. * Debug-level logs are only logged if {@link Component#debug} is `true`. * * Will attempt to use appropriate `console` methods if they are available. * * @method Component#log * @param {string} level Log level. * @param {...*} [args] Values to log. * @since 3.0.0 */ utils.logify(Component.prototype) /** * Register a new event listener on this Component. * * @example * // Listen for all &quot;afterCreate&quot; events in a DataStore * store.on('afterCreate', (mapperName, props, opts, result) =&gt; { * console.log(mapperName) // &quot;post&quot; * console.log(props.id) // undefined * console.log(result.id) // 1234 * }) * store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { * console.log(post.id) // 1234 * }) * * @example * // Listen for the &quot;add&quot; event on a collection * collection.on('add', (records) =&gt; { * console.log(records) // [...] * }) * * @example * // Listen for &quot;change&quot; events on a record * post.on('change', (record, changes) =&gt; { * console.log(changes) // { changed: { title: 'Modeling your data' } } * }) * post.title = 'Modeling your data' * * @method Component#on * @param {string} event Name of event to subsribe to. * @param {Function} listener Listener function to handle the event. * @param {*} [ctx] Optional content in which to invoke the listener. * @since 3.0.0 */ /** * Remove an event listener from this Component. If no listener is provided, * then all listeners for the specified event will be removed. If no event is * specified then all listeners for all events will be removed. * * @example * // Remove a particular listener for a particular event * collection.off('add', handler) * * @example * // Remove all listeners for a particular event * record.off('change') * * @example * // Remove all listeners to all events * store.off() * * @method Component#off * @param {string} [event] Name of event to unsubsribe to. * @param {Function} [listener] Listener to remove. * @since 3.0.0 */ /** * Trigger an event on this Component. * * @example &lt;caption&gt;Component#emit&lt;/caption&gt; * // import {Collection, DataStore} from 'js-data' * const JSData = require('js-data@3.0.0-rc.4') * const {Collection, DataStore} = JSData * * const collection = new Collection() * collection.on('foo', function (msg) { * console.log(msg) * }) * collection.emit('foo', 'bar') * * const store = new DataStore() * store.on('beep', function (msg) { * console.log(msg) * }) * store.emit('beep', 'boop') * * @method Component#emit * @param {string} event Name of event to emit. * @param {...*} [args] Arguments to pass to any listeners. * @since 3.0.0 */ utils.eventify( Component.prototype, function () { return this._listeners }, function (value) { this._listeners = value } )  Search results Close api.js-data.io  js-data.io "},"src_index.js.html":{"id":"src_index.js.html","title":"Source: src/index.js","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Source: src/index.js import { utils } from 'js-data' import axios from '../node_modules/axios/dist/axios' import { Adapter, noop, noop2 } from '../node_modules/js-data-adapter/src/index' let hasFetch = false try { hasFetch = window &amp;&amp; window.fetch } catch (e) {} function isValidString (value) { return (value != null &amp;&amp; value !== '') } function join (items, separator) { separator || (separator = '') return items.filter(isValidString).join(separator) } function makePath (...args) { let result = join(args, '/') return result.replace(/([^:/]|^)\\/{2,}/g, '$1/') } function encode (val) { return encodeURIComponent(val) .replace(/%40/gi, '@') .replace(/%3A/gi, ':') .replace(/%24/g, '$') .replace(/%2C/gi, ',') .replace(/%20/g, '+') .replace(/%5B/gi, '[') .replace(/%5D/gi, ']') } function buildUrl (url, params) { if (!params) { return url } const parts = [] utils.forOwn(params, function (val, key) { if (val === null || typeof val === 'undefined') { return } if (!utils.isArray(val)) { val = [val] } val.forEach(function (v) { if (toString.call(v) === '[object Date]') { v = v.toISOString() } else if (utils.isObject(v)) { v = utils.toJson(v) } parts.push(`${encode(key)}=${encode(v)}`) }) }) if (parts.length &gt; 0) { url += (url.indexOf('?') === -1 ? '?' : '&amp;') + parts.join('&amp;') } return url } const DEFAULTS = { /** * Set a base path in order to use absolute URLs instead of relative URLs. * * @example * const httpAdapter = new HttpAdapter({ * basePath: 'https://mydomain.com' * }); * * @name HttpAdapter#basePath * @type {string} * @since 3.0.0 */ basePath: '', /** * Ensure that the request url has a trailing forward slash. * * @name HttpAdapter#forceTrailingSlash * @type {boolean} * @default false * @since 3.0.0 */ forceTrailingSlash: false, hasFetch: hasFetch, /** * The HTTP function that actually makes the HTTP request. By default this is * `axios`. * * @name HttpAdapter#http * @type {function} * @since 3.0.0 * @see http://www.js-data.io/docs/js-data-http#using-a-custom-http-library */ http: axios, /** * Default configuration options to be mixed into the `config` argument passed * to {@link HttpAdapter#http}. * * @name HttpAdapter#httpConfig * @type {object} * @since 3.0.0 */ httpConfig: {}, /** * Add a suffix to the request url, e.g. &quot;.json&quot;. * * @name HttpAdapter#suffix * @type {string} * @since 3.0.0 */ suffix: '', /** * Use `window.fetch` if available. * * @name HttpAdapter#useFetch * @type {boolean} * @default false * @since 3.0.0 * @see http://www.js-data.io/docs/js-data-http#using-windowfetch */ useFetch: false } /** * HttpAdapter class. * * @example * import { DataStore } from 'js-data'; * import { HttpAdapter } from 'js-data-http'; * * const httpAdapter = new HttpAdapter(); * const store = new DataStore(); * * store.registerAdapter('http', httpAdapter, { 'default': true }); * * store.defineMapper('school'); * store.defineMapper('student'); * * // GET /school/1 * store.find('school', 1).then((school) =&gt; { * console.log('school'); * }); * * @class HttpAdapter * @extends Adapter * @param {object} [opts] Configuration options. * @param {string} [opts.basePath=''] See {@link HttpAdapter#basePath}. * @param {boolean} [opts.debug=false] See {@link HttpAdapter#debug}. * @param {boolean} [opts.forceTrailingSlash=false] See {@link HttpAdapter#forceTrailingSlash}. * @param {object} [opts.http=axios] See {@link HttpAdapter#http}. * @param {object} [opts.httpConfig={}] See {@link HttpAdapter#httpConfig}. * @param {string} [opts.suffix=''] See {@link HttpAdapter#suffix}. * @param {boolean} [opts.useFetch=false] See {@link HttpAdapter#useFetch}. * @see http://www.js-data.io/docs/js-data-http */ export function HttpAdapter (opts) { utils.classCallCheck(this, HttpAdapter) opts || (opts = {}) // Fill in any missing options with the defaults utils.fillIn(opts, DEFAULTS) Adapter.call(this, opts) } /** * @name module:js-data-http.HttpAdapter * @see HttpAdapter */ Adapter.extend({ constructor: HttpAdapter, /** * @name HttpAdapter#afterDEL * @method * @param {string} url * @param {object} config * @param {object} opts * @param {object} response */ afterDEL: noop2, /** * @name HttpAdapter#afterGET * @method * @param {string} url * @param {object} config * @param {object} opts * @param {object} response */ afterGET: noop2, /** * @name HttpAdapter#afterHTTP * @method * @param {object} config * @param {object} opts * @param {object} response */ afterHTTP: noop2, /** * @name HttpAdapter#afterPOST * @method * @param {string} url * @param {object} data * @param {object} config * @param {object} opts * @param {object} response */ afterPOST: noop2, /** * @name HttpAdapter#afterPUT * @method * @param {string} url * @param {object} data * @param {object} config * @param {object} opts * @param {object} response */ afterPUT: noop2, /** * @name HttpAdapter#beforeDEL * @method * @param {object} url * @param {object} config * @param {object} opts */ beforeDEL: noop, /** * @name HttpAdapter#beforeGET * @method * @param {object} url * @param {object} config * @param {object} opts */ beforeGET: noop, /** * @name HttpAdapter#beforeHTTP * @method * @param {object} config * @param {object} opts */ beforeHTTP: noop, /** * @name HttpAdapter#beforePOST * @method * @param {object} url * @param {object} data * @param {object} config * @param {object} opts */ beforePOST: noop, /** * @name HttpAdapter#beforePUT * @method * @param {object} url * @param {object} data * @param {object} config * @param {object} opts */ beforePUT: noop, _count (mapper, query, opts) { return this.GET( this.getPath('count', mapper, opts.params, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _create (mapper, props, opts) { return this.POST( this.getPath('create', mapper, props, opts), this.serialize(mapper, props, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _createMany (mapper, props, opts) { return this.POST( this.getPath('createMany', mapper, null, opts), this.serialize(mapper, props, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _destroy (mapper, id, opts) { return this.DEL( this.getPath('destroy', mapper, id, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _destroyAll (mapper, query, opts) { return this.DEL( this.getPath('destroyAll', mapper, null, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _end (mapper, opts, response) { return [this.deserialize(mapper, response, opts), response] }, _find (mapper, id, opts) { return this.GET( this.getPath('find', mapper, id, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _findAll (mapper, query, opts) { return this.GET( this.getPath('findAll', mapper, opts.params, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _sum (mapper, field, query, opts) { return this.GET( this.getPath('sum', mapper, opts.params, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _update (mapper, id, props, opts) { return this.PUT( this.getPath('update', mapper, id, opts), this.serialize(mapper, props, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _updateAll (mapper, props, query, opts) { return this.PUT( this.getPath('updateAll', mapper, null, opts), this.serialize(mapper, props, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, _updateMany (mapper, records, opts) { return this.PUT( this.getPath('updateMany', mapper, null, opts), this.serialize(mapper, records, opts), opts ).then((response) =&gt; this._end(mapper, opts, response)) }, /** * Retrieve the number of records that match the selection `query`. * * @name HttpAdapter#count * @method * @param {object} mapper The mapper. * @param {object} query Selection query. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ count (mapper, query, opts) { query || (query = {}) opts || (opts = {}) opts.params = this.getParams(opts) opts.params.count = true opts.suffix = this.getSuffix(mapper, opts) utils.deepMixIn(opts.params, query) opts.params = this.queryTransform(mapper, opts.params, opts) return Adapter.prototype.count.call(this, mapper, query, opts) }, /** * Create a new the record from the provided `props`. * * @name HttpAdapter#create * @method * @param {object} mapper The mapper. * @param {object} props Properties to send as the payload. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ create (mapper, props, opts) { opts || (opts = {}) opts.params = this.getParams(opts) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.create.call(this, mapper, props, opts) }, /** * Create multiple new records in batch. * * @name HttpAdapter#createMany * @method * @param {object} mapper The mapper. * @param {array} props Array of property objects to send as the payload. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ createMany (mapper, props, opts) { opts || (opts = {}) opts.params = this.getParams(opts) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.createMany.call(this, mapper, props, opts) }, /** * Make an Http request to `url` according to the configuration in `config`. * * @name HttpAdapter#DEL * @method * @param {string} url Url for the request. * @param {object} [config] Http configuration that will be passed to * {@link HttpAdapter#HTTP}. * @param {object} [opts] Configuration options. * @return {Promise} */ DEL (url, config, opts) { let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.method = config.method || 'delete' // beforeDEL lifecycle hook op = opts.op = 'beforeDEL' return utils.resolve(this[op](url, config, opts)) .then((_config) =&gt; { // Allow re-assignment from lifecycle hook config = _config === undefined ? config : _config op = opts.op = 'DEL' this.dbg(op, url, config, opts) return this.HTTP(config, opts) }) .then((response) =&gt; { // afterDEL lifecycle hook op = opts.op = 'afterDEL' return utils.resolve(this[op](url, config, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Transform the server response object into the payload that will be returned * to JSData. * * @name HttpAdapter#deserialize * @method * @param {object} mapper The mapper used for the operation. * @param {object} response Response object from {@link HttpAdapter#HTTP}. * @param {object} opts Configuration options. * @return {(object|array)} Deserialized data. */ deserialize (mapper, response, opts) { opts || (opts = {}) if (utils.isFunction(opts.deserialize)) { return opts.deserialize(mapper, response, opts) } if (utils.isFunction(mapper.deserialize)) { return mapper.deserialize(mapper, response, opts) } if (response &amp;&amp; response.hasOwnProperty('data')) { return response.data } return response }, /** * Destroy the record with the given primary key. * * @name HttpAdapter#destroy * @method * @param {object} mapper The mapper. * @param {(string|number)} id Primary key of the record to destroy. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ destroy (mapper, id, opts) { opts || (opts = {}) opts.params = this.getParams(opts) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.destroy.call(this, mapper, id, opts) }, /** * Destroy the records that match the selection `query`. * * @name HttpAdapter#destroyAll * @method * @param {object} mapper The mapper. * @param {object} query Selection query. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ destroyAll (mapper, query, opts) { query || (query = {}) opts || (opts = {}) opts.params = this.getParams(opts) utils.deepMixIn(opts.params, query) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.destroyAll.call(this, mapper, query, opts) }, /** * Log an error. * * @name HttpAdapter#error * @method * @param {...*} [args] Arguments to log. */ error (...args) { if (console) { console[typeof console.error === 'function' ? 'error' : 'log'](...args) } }, /** * Make an Http request using `window.fetch`. * * @name HttpAdapter#fetch * @method * @param {object} config Request configuration. * @param {object} config.data Payload for the request. * @param {string} config.method Http method for the request. * @param {object} config.headers Headers for the request. * @param {object} config.params Querystring for the request. * @param {string} config.url Url for the request. */ fetch (config) { const requestConfig = { method: config.method, // turn the plain headers object into the Fetch Headers object headers: new Headers(config.headers || {}) } if (config.data) { requestConfig.body = utils.toJson(config.data) } return fetch(buildUrl(config.url, config.params), requestConfig) .then((response) =&gt; { response.config = { method: config.method, url: config.url } return response.json() .then((data) =&gt; { response.data = data return response }) }) }, /** * Retrieve the record with the given primary key. * * @name HttpAdapter#find * @method * @param {object} mapper The mapper. * @param {(string|number)} id Primary key of the record to retrieve. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ find (mapper, id, opts) { opts || (opts = {}) opts.params = this.getParams(opts) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.find.call(this, mapper, id, opts) }, /** * Retrieve the records that match the selection `query`. * * @name HttpAdapter#findAll * @method * @param {object} mapper The mapper. * @param {object} query Selection query. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ findAll (mapper, query, opts) { query || (query = {}) opts || (opts = {}) opts.params = this.getParams(opts) opts.suffix = this.getSuffix(mapper, opts) utils.deepMixIn(opts.params, query) opts.params = this.queryTransform(mapper, opts.params, opts) return Adapter.prototype.findAll.call(this, mapper, query, opts) }, /** * Make a GET request. * * @name HttpAdapter#GET * @method * @param {string} url The url for the request. * @param {object} config Request configuration options. * @param {object} [opts] Configuration options. * @return {Promise} */ GET (url, config, opts) { let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.method = config.method || 'get' // beforeGET lifecycle hook op = opts.op = 'beforeGET' return utils.resolve(this[op](url, config, opts)) .then((_config) =&gt; { // Allow re-assignment from lifecycle hook config = _config === undefined ? config : _config op = opts.op = 'GET' this.dbg(op, url, config, opts) return this.HTTP(config, opts) }) .then((response) =&gt; { // afterGET lifecycle hook op = opts.op = 'afterGET' return utils.resolve(this[op](url, config, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * @name HttpAdapter#getEndpoint * @method * @param {object} mapper The Mapper. * @param {*} id The primary key, if any. * @param {boolean} opts Configuration options. * @return {string} Full path. */ getEndpoint (mapper, id, opts) { opts || (opts = {}) opts.params = utils.isUndefined(opts.params) ? {} : opts.params const relationList = mapper.relationList || [] let endpoint = utils.isUndefined(opts.endpoint) ? (utils.isUndefined(mapper.endpoint) ? mapper.name : mapper.endpoint) : opts.endpoint relationList.forEach((def) =&gt; { if (def.type !== 'belongsTo' || !def.parent) { return } let item const parentKey = def.foreignKey const parentDef = def.getRelation() let parentId = opts.params[parentKey] if (parentId === false || !parentKey || !parentDef) { if (parentId === false) { delete opts.params[parentKey] } return false } else { delete opts.params[parentKey] if (utils.isObject(id)) { item = id } if (item) { parentId = parentId || def.getForeignKey(item) || (def.getLocalField(item) ? utils.get(def.getLocalField(item), parentDef.idAttribute) : null) } if (parentId) { delete opts.endpoint const _opts = {} utils.forOwn(opts, (value, key) =&gt; { _opts[key] = value }) utils._(_opts, parentDef) endpoint = makePath(this.getEndpoint(parentDef, parentId, _opts), parentId, endpoint) return false } } }) return endpoint }, /** * @name HttpAdapter#getPath * @method * @param {string} method The method being executed. * @param {object} mapper The Mapper. * @param {(string|number)?} id The primary key, if any. * @param {object} opts Configuration options. */ getPath (method, mapper, id, opts) { opts || (opts = {}) const args = [ opts.basePath === undefined ? (mapper.basePath === undefined ? this.basePath : mapper.basePath) : opts.basePath, this.getEndpoint(mapper, (utils.isString(id) || utils.isNumber(id) || method === 'create') ? id : null, opts) ] if (method === 'find' || method === 'update' || method === 'destroy') { args.push(id) } return makePath.apply(utils, args) }, getParams (opts) { opts || (opts = {}) if (opts.params === undefined) { return {} } return utils.copy(opts.params) }, getSuffix (mapper, opts) { opts || (opts = {}) if (opts.suffix === undefined) { if (mapper.suffix === undefined) { return this.suffix } return mapper.suffix } return opts.suffix }, /** * Make an Http request. * * @name HttpAdapter#HTTP * @method * @param {object} config Request configuration options. * @param {object} [opts] Configuration options. * @return {Promise} */ HTTP (config, opts) { const start = new Date() opts || (opts = {}) const payload = config.data const cache = config.cache const timeout = config.timeout config = utils.copy(config, null, null, null, ['data', 'cache', 'timeout']) config = utils.deepMixIn(config, this.httpConfig) config.data = payload config.cache = cache if (timeout !== undefined) { config.timeout = timeout } if (this.forceTrailingSlash &amp;&amp; config.url[config.url.length - 1] !== '/') { config.url += '/' } config.method = config.method.toUpperCase() const suffix = config.suffix || opts.suffix || this.suffix if (suffix &amp;&amp; config.url.substr(config.url.length - suffix.length) !== suffix) { config.url += suffix } const logResponse = (data) =&gt; { const str = `${start.toUTCString()} - ${config.method.toUpperCase()} ${config.url} - ${data.status} ${(new Date().getTime() - start.getTime())}ms` if (data.status &gt;= 200 &amp;&amp; data.status &lt; 300) { if (this.log) { this.dbg(str, data) } return data } else { if (this.error) { this.error(`'FAILED: ${str}`, data) } return utils.reject(data) } } if (!this.http) { if ((this.useFetch || opts.useFetch)) { if (!hasFetch) { throw new Error('Attempting to use window.fetch, but it is not available!') } } else { throw new Error('You have not configured this adapter with an http library!') } } return utils.resolve(this.beforeHTTP(config, opts)) .then((_config) =&gt; { config = _config || config if (hasFetch &amp;&amp; (this.useFetch || opts.useFetch || !this.http)) { return this.fetch(config, opts).then(logResponse, logResponse) } const httpConfig = utils.plainCopy(config) delete httpConfig.adapter return this.http(httpConfig).then(logResponse, logResponse) .catch((err) =&gt; this.responseError(err, config, opts)) }) .then((response) =&gt; { return utils.resolve(this.afterHTTP(config, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Make a POST request. * * @name HttpAdapter#POST * @method * @param {*} url The url for the request. * @param {object} data Payload for the request. * @param {object} config Request configuration options. * @param {object} [opts] Configuration options. * @return {Promise} */ POST (url, data, config, opts) { let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.data = data || config.data config.method = config.method || 'post' // beforePOST lifecycle hook op = opts.op = 'beforePOST' return utils.resolve(this[op](url, data, config, opts)) .then((_config) =&gt; { // Allow re-assignment from lifecycle hook config = _config === undefined ? config : _config op = opts.op = 'POST' this.dbg(op, url, data, config, opts) return this.HTTP(config, opts) }) .then((response) =&gt; { // afterPOST lifecycle hook op = opts.op = 'afterPOST' return utils.resolve(this[op](url, data, config, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Make a PUT request. * * @name HttpAdapter#PUT * @method * @param {*} url The url for the request. * @param {object} data Payload for the request. * @param {object} config Request configuration options. * @param {object} [opts] Configuration options. * @return {Promise} */ PUT (url, data, config, opts) { let op config || (config = {}) opts || (opts = {}) config.url = url || config.url config.data = data || config.data config.method = config.method || 'put' // beforePUT lifecycle hook op = opts.op = 'beforePUT' return utils.resolve(this[op](url, data, config, opts)) .then((_config) =&gt; { // Allow re-assignment from lifecycle hook config = _config === undefined ? config : _config op = opts.op = 'PUT' this.dbg(op, url, data, config, opts) return this.HTTP(config, opts) }) .then((response) =&gt; { // afterPUT lifecycle hook op = opts.op = 'afterPUT' return utils.resolve(this[op](url, data, config, opts, response)) .then((_response) =&gt; _response === undefined ? response : _response) }) }, /** * Transform the querystring object before it is serialized. This doesn't do * anything by default. * * @name HttpAdapter#queryTransform * @method * @param {object} mapper The Mapper that triggered the request. * @param {*} params The querystring object. * @param {*} opts Configuration options * @return {*} Transformed params. */ queryTransform (mapper, params, opts) { opts || (opts = {}) if (utils.isFunction(opts.queryTransform)) { return opts.queryTransform(mapper, params, opts) } if (utils.isFunction(mapper.queryTransform)) { return mapper.queryTransform(mapper, params, opts) } return params }, /** * Error handler invoked when the promise returned by {@link HttpAdapter#http} * is rejected. Default implementation is to just return the error wrapped in * a rejected Promise, aka rethrow the error. {@link HttpAdapter#http} is * called by {@link HttpAdapter#HTTP}. * * @name HttpAdapter#responseError * @method * @param {*} err The error that {@link HttpAdapter#http} rejected with. * @param {object} config The `config` argument that was passed to {@link HttpAdapter#HTTP}. * @param {*} opts The `opts` argument that was passed to {@link HttpAdapter#HTTP}. * @return {Promise} */ responseError (err, config, opts) { return utils.reject(err) }, /** * Serialize request data. This doesn't do anything by default. * * @name HttpAdapter#serialize * @method * @param {object} mapper The Mapper that triggered the request. * @param {object} data The request payload. * @param {*} opts Configuration options. * @return {*} Serialized data. */ serialize (mapper, data, opts) { opts || (opts = {}) if (utils.isFunction(opts.serialize)) { return opts.serialize(mapper, data, opts) } if (utils.isFunction(mapper.serialize)) { return mapper.serialize(mapper, data, opts) } return data }, /** * Retrieve the sum of the field of the records that match the selection query. * * @name HttpAdapter#sum * @method * @param {object} mapper The mapper. * @param {string} field The field to sum. * @param {object} query Selection query. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ sum (mapper, field, query, opts) { query || (query = {}) opts || (opts = {}) if (!utils.isString(field)) { throw new Error('field must be a string!') } opts.params = this.getParams(opts) opts.params.sum = field opts.suffix = this.getSuffix(mapper, opts) utils.deepMixIn(opts.params, query) opts.params = this.queryTransform(mapper, opts.params, opts) return Adapter.prototype.sum.call(this, mapper, field, query, opts) }, /** * Perform an update. Makes a PUT request by default. * * @name HttpAdapter#update * @method * @param {object} mapper The Mapper for the request. * @param {*} id The primary key of the record being updated. * @param {*} props The update payload. * @param {object} [opts] Configuration options. * @return {Promise} */ update (mapper, id, props, opts) { opts || (opts = {}) opts.params = this.getParams(opts) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.update.call(this, mapper, id, props, opts) }, /** * Perform an update against records that match the selection query. Makes a * PUT request by default. * * @name HttpAdapter#updateAll * @method * @param {object} mapper The Mapper for the request. * @param {object} props The update payload. * @param {object} query The selection query. See {@link http://www.js-data.io/docs/query-syntax}. * @param {object} [opts] Configuration options. * @return {Promise} */ updateAll (mapper, props, query, opts) { query || (query = {}) opts || (opts = {}) opts.params = this.getParams(opts) utils.deepMixIn(opts.params, query) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.updateAll.call(this, mapper, props, query, opts) }, /** * Update multiple individual records in a batch. * * @name HttpAdapter#updateMany * @method * @param {object} mapper The Mapper for the request. * @param {array} records Array of property objects to send as the payload. * Each must contain the primary key of the record to be updated. * @param {object} [opts] Configuration options. * @param {string} [opts.params] Querystring parameters. * @param {string} [opts.suffix={@link HttpAdapter#suffix}] See {@link HttpAdapter#suffix}. * @return {Promise} */ updateMany (mapper, records, opts) { opts || (opts = {}) opts.params = this.getParams(opts) opts.params = this.queryTransform(mapper, opts.params, opts) opts.suffix = this.getSuffix(mapper, opts) return Adapter.prototype.updateMany.call(this, mapper, records, opts) } }) /** * Add an Http actions to a mapper. * * @example * // CommonJS * var JSData = require('js-data'); * // It is recommended to use DataStore in the browser * var DataStore = JSData.DataStore; * * var JSDataHttp = require('js-data-http'); * var HttpAdapter = JSDataHttp.HttpAdapter; * var addAction = JSDataHttp.addAction; * * var httpAdapter = new HttpAdapter(); * var store = new DataStore(); * * store.registerAdapter('http', httpAdapter, { 'default': true }); * store.defineMapper('school'); * * // GET /reports/schools/:school_id/teachers * addAction('getTeacherReports', { * endpoint: 'reports/schools', * pathname: 'teachers', * method: 'GET' * })(store.getMapper('school')); * * // /reports/schools/1234/teachers * store.getMapper('school').getTeacherReports(1234).then((response) =&gt; { * // ... * }); * * @name module:js-data-http.addAction * @method * @param {string} name Name of the new action. * @param {object} [opts] Action configuration * @param {string} [opts.adapter=&quot;http&quot;] The name of the adapter to use. * @param {string} [opts.pathname] Set the action's pathname. * @param {function} [opts.request] Specify a request handler to be executed * before the request is made. * @param {function} [opts.response] Specify a response handler to be executed * after the response is received. * @param {function} [opts.responseError] Specify an error handler to be * executed on error. * @return {function} Decoration function, which should be passed the mapper to * decorate when invoked. */ export function addAction (name, opts) { if (!name || !utils.isString(name)) { throw new TypeError('action(name[, opts]): Expected: string, Found: ' + typeof name) } return function (mapper) { if (mapper[name]) { throw new Error('action(name[, opts]): ' + name + ' already exists on target!') } opts.request = opts.request || function (config) { return config } opts.response = opts.response || function (response) { return response } opts.responseError = opts.responseError || function (err) { return utils.reject(err) } mapper[name] = function (id, _opts) { _opts = _opts || {} if (utils.isObject(id)) { _opts = id } utils.fillIn(_opts, opts) let adapter = this.getAdapter(_opts.adapter || this.defaultAdapter || 'http') const config = {} config.mapper = this.name utils.deepMixIn(config, _opts) config.method = config.method || 'GET' if (typeof _opts.getEndpoint === 'function') { config.url = _opts.getEndpoint(this, _opts) } else { let args = [ _opts.basePath || this.basePath || adapter.basePath, adapter.getEndpoint(this, id, _opts) ] if (utils.isSorN(id)) { args.push(id) } args.push(opts.pathname || name) config.url = makePath.apply(null, args) } return utils.resolve(config) .then(_opts.request) .then((config) =&gt; adapter.HTTP(config)) .then((data) =&gt; { if (data &amp;&amp; data.config) { data.config.mapper = this.name } return data }) .then(_opts.response, _opts.responseError) } return mapper } } /** * Add multiple Http actions to a mapper. See {@link HttpAdapter.addAction} for * action configuration options. * * @example * // CommonJS * var JSData = require('js-data'); * // It is recommended to use DataStore in the browser * var DataStore = JSData.DataStore; * * var JSDataHttp = require('js-data-http'); * var HttpAdapter = JSDataHttp.HttpAdapter; * var addActions = JSDataHttp.addActions; * * var httpAdapter = new HttpAdapter(); * var store = new DataStore(); * * store.registerAdapter('http', httpAdapter, { 'default': true }); * store.defineMapper('school'); * * addActions({ * // GET /reports/schools/:school_id/teachers * getTeacherReports: { * basePath: 'reports/schools', * pathname: 'teachers', * method: 'GET' * } * })(store.getMapper('school')); * * // /reports/schools/1234/teachers * store.getMapper('school').getTeacherReports(1234).then((response) =&gt; { * // ... * }); * * @name module:js-data-http.addActions * @method * @param {object.&lt;string, object&gt;} opts Object where the key is an action name * and the value is the configuration for the action. * @return {function} Decoration function, which should be passed the mapper to * decorate when invoked. */ export function addActions (opts) { opts || (opts = {}) return function (mapper) { utils.forOwn(opts, function (value, key) { addAction(key, value)(mapper) }) return mapper } } /** * Details of the current version of the `js-data-http` module. * * @name module:js-data-http.version * @type {object} * @property {string} version.full The full semver value. * @property {number} version.major The major version number. * @property {number} version.minor The minor version number. * @property {number} version.patch The patch version number. * @property {(string|boolean)} version.alpha The alpha version value, * otherwise `false` if the current version is not alpha. * @property {(string|boolean)} version.beta The beta version value, * otherwise `false` if the current version is not beta. */ export const version = '&lt;%= version %&gt;' /** * Registered as `js-data-http` in NPM and Bower. The build of `js-data-http` * that works on Node.js is registered in NPM as `js-data-http-node`. The build * of `js-data-http` that does not bundle `axios` is registered in NPM and Bower * as `js-data-fetch`. * * @example &lt;caption&gt;Script tag&lt;/caption&gt; * var HttpAdapter = window.JSDataHttp.HttpAdapter; * var httpAdapter = new HttpAdapter(); * * @example &lt;caption&gt;CommonJS&lt;/caption&gt; * var HttpAdapter = require('js-data-Http').HttpAdapter; * var httpAdapter = new HttpAdapter(); * * @example &lt;caption&gt;ES2015 Modules&lt;/caption&gt; * import { HttpAdapter } from 'js-data-Http'; * const httpAdapter = new HttpAdapter(); * * @example &lt;caption&gt;AMD&lt;/caption&gt; * define('myApp', ['js-data-Http'], function (JSDataHttp) { * var HttpAdapter = JSDataHttp.HttpAdapter; * var httpAdapter = new HttpAdapter(); * * // ... * }); * * @module js-data-http */ /** * Create a subclass of this HttpAdapter: * @example &lt;caption&gt;HttpAdapter.extend&lt;/caption&gt; * // Normally you would do: import { HttpAdapter } from 'js-data-http'; * // or: import { HttpAdapter } from 'js-data-http-node'; * const JSDataHttp = require('js-data-http-node'); * const { HttpAdapter } = JSDataHttp; * console.log('Using JSDataHttp v' + JSDataHttp.version.full); * * // Extend the class using ES2015 class syntax. * class CustomHttpAdapterClass extends HttpAdapter { * foo () { return 'bar'; } * static beep () { return 'boop'; } * } * const customHttpAdapter = new CustomHttpAdapterClass(); * console.log(customHttpAdapter.foo()); * console.log(CustomHttpAdapterClass.beep()); * * // Extend the class using alternate method. * const OtherHttpAdapterClass = HttpAdapter.extend({ * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const otherHttpAdapter = new OtherHttpAdapterClass(); * console.log(otherHttpAdapter.foo()); * console.log(OtherHttpAdapterClass.beep()); * * // Extend the class, providing a custom constructor. * function AnotherHttpAdapterClass () { * HttpAdapter.call(this); * this.created_at = new Date().getTime(); * } * HttpAdapter.extend({ * constructor: AnotherHttpAdapterClass, * foo () { return 'bar'; } * }, { * beep () { return 'boop'; } * }) * const anotherHttpAdapter = new AnotherHttpAdapterClass(); * console.log(anotherHttpAdapter.created_at); * console.log(anotherHttpAdapter.foo()); * console.log(AnotherHttpAdapterClass.beep()); * * @method HttpAdapter.extend * @param {object} [props={}] Properties to add to the prototype of the * subclass. * @param {object} [props.constructor] Provide a custom constructor function * to be used as the subclass itself. * @param {object} [classProps={}] Static properties to add to the subclass. * @returns {Constructor} Subclass of this HttpAdapter class. * @since 3.0.0 */  Search results Close api.js-data.io  js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Modules Details Classes Adapter Component HttpAdapter Response  Search results Close api.js-data.io  js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Classes Details Classes Adapter Component HttpAdapter Response  Search results Close api.js-data.io  js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse js-data-http 3.0.0 js-data-http This repo contains HTTP adapters for js-data: js-data-http - HTTP (XHR, includes [axios][axios]) adapter for JSData in the browser. Capable of using window.fetch instead of axios. Only works in the browser. js-data-fetch - Same as js-data-http but does not include axios and will use window.fetch if available and if you don't provide your own http library. js-data-http-node - Same as js-data-http but runs on Node.js. Depends on axios and will use axios unless you provide a different http library. Tested on IE9, Chrome 46, Firefox 41 &amp; Safari 7.1 using To get started, visit the main website at http://js-data.io. Links Quick start - Get started in 5 minutes Guides and Tutorials - Learn how to use JSData HttpAdapter Guide - Learn how to use the HttpAdapter API Reference Docs - Explore components, methods, options, etc. Community &amp; Support - Find solutions and chat with the community General Contributing Guide - Give back and move the project forward Contributing to js-data-http LicenseThe MIT License (MIT) Copyright (c) 2014-2016 js-data-http project authors LICENSE AUTHORS CONTRIBUTORS  Search results Close api.js-data.io  js-data.io "},"Adapter.html":{"id":"Adapter.html","title":"Class: Adapter","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Class: Adapter Adapter &lt;abstract&gt; new Adapter(opts) Abstract class meant to be extended by adapters. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration opts. Properties Name Type Argument Default Description debug Boolean &lt;optional&gt; false Whether to log debugging information. raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Details Source node_modules/js-data-adapter/src/index.js, line 93 Extends This class extends the Component class. Members debug Whether to log debugging information. Details Type Default value Source Overrides Boolean false node_modules/js-data-adapter/src/index.js, line 74 Component#debug raw Whether to return a more detailed response object. Details Type Default value Source Boolean false node_modules/js-data-adapter/src/index.js, line 83 Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Adapter: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Adapter class. Details Source node_modules/js-data-adapter/src/index.js, line 1396 Example Try it out // Normally you would do: import {Adapter} from 'js-data' const JSData = require('js-data@3.0.0-beta.10') const {Adapter} = JSData console.log('Using JSData v' + JSData.version.full) // Extend the class using ES2015 class syntax. class CustomAdapterClass extends Adapter { foo () { return 'bar' } static beep () { return 'boop' } } const customAdapter = new CustomAdapterClass() console.log(customAdapter.foo()) console.log(CustomAdapterClass.beep()) // Extend the class using alternate method. const OtherAdapterClass = Adapter.extend({ foo () { return 'bar' } }, { beep () { return 'boop' } }) const otherAdapter = new OtherAdapterClass() console.log(otherAdapter.foo()) console.log(OtherAdapterClass.beep()) // Extend the class, providing a custom constructor. function AnotherAdapterClass () { Adapter.call(this) this.created_at = new Date().getTime() } Adapter.extend({ constructor: AnotherAdapterClass, foo () { return 'bar' } }, { beep () { return 'boop' } }) const anotherAdapter = new AnotherAdapterClass() console.log(anotherAdapter.created_at) console.log(anotherAdapter.foo()) console.log(AnotherAdapterClass.beep()) // Normally you would do: import {Adapter} from 'js-data' const JSData = require('js-data@3.0.0-beta.10') const {Adapter} = JSData console.log('Using JSData v' + JSData.version.full) // Extend the class using ES2015 class syntax. class CustomAdapterClass extends Adapter { foo () { return 'bar' } static beep () { return 'boop' } } const customAdapter = new CustomAdapterClass() console.log(customAdapter.foo()) console.log(CustomAdapterClass.beep()) // Extend the class using alternate method. const OtherAdapterClass = Adapter.extend({ foo () { return 'bar' } }, { beep () { return 'boop' } }) const otherAdapter = new OtherAdapterClass() console.log(otherAdapter.foo()) console.log(OtherAdapterClass.beep()) // Extend the class, providing a custom constructor. function AnotherAdapterClass () { Adapter.call(this) this.created_at = new Date().getTime() } Adapter.extend({ constructor: AnotherAdapterClass, foo () { return 'bar' } }, { beep () { return 'boop' } }) const anotherAdapter = new AnotherAdapterClass() console.log(anotherAdapter.created_at) console.log(anotherAdapter.foo()) console.log(AnotherAdapterClass.beep()) afterCount(mapper, props, opts, response) Lifecycle method method called by count. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes count to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the count. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by count. Method parameters: Name Type Description mapper Object The mapper argument passed to count. props Object The props argument passed to count. opts Object The opts argument passed to count. response Object | Response Count or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 115 Properties: Name Type Description opts.op String afterCount afterCreate(mapper, props, opts, response) Lifecycle method method called by create. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes create to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the created record. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by create. Method parameters: Name Type Description mapper Object The mapper argument passed to create. props Object The props argument passed to create. opts Object The opts argument passed to create. response Object | Response Created record or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 138 Properties: Name Type Description opts.op String afterCreate afterCreate(mapper, props, opts, response) Lifecycle method method called by createMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes createMany to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the created records. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by createMany. Method parameters: Name Type Description mapper Object The mapper argument passed to createMany. props Array.&lt;Object&gt; The props argument passed to createMany. opts Object The opts argument passed to createMany. response Array.&lt;Object&gt; | Response Created records or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 161 Properties: Name Type Description opts.op String afterCreateMany afterDestroy(mapper, id, opts, response) Lifecycle method method called by destroy. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroy to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be undefined. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroy. Method parameters: Name Type Description mapper Object The mapper argument passed to destroy. id String | Number The id argument passed to destroy. opts Object The opts argument passed to destroy. response undefined | Response undefined or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 184 Properties: Name Type Description opts.op String afterDestroy afterDestroyAll(mapper, query, opts, response) Lifecycle method method called by destroyAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroyAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be undefined. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroyAll. Method parameters: Name Type Description mapper Object The mapper argument passed to destroyAll. query Object The query argument passed to destroyAll. opts Object The opts argument passed to destroyAll. response undefined | Response undefined or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 207 Properties: Name Type Description opts.op String afterDestroyAll afterFind(mapper, id, opts, response) Lifecycle method method called by find. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes find to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the found record, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by find. Method parameters: Name Type Description mapper Object The mapper argument passed to find. id String | Number The id argument passed to find. opts Object The opts argument passed to find. response Object | Response The found record or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 230 Properties: Name Type Description opts.op String afterFind afterFindAll(mapper, query, opts, response) Lifecycle method method called by findAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes findAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the found records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by findAll. Method parameters: Name Type Description mapper Object The mapper argument passed to findAll. query Object The query argument passed to findAll. opts Object The opts argument passed to findAll. response Array.&lt;Object&gt; | Response The found records or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 253 Properties: Name Type Description opts.op String afterFindAll afterSum(mapper, field, query, opts, response) Lifecycle method method called by sum. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes sum to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the sum. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by sum. Method parameters: Name Type Description mapper Object The mapper argument passed to sum. field String The field argument passed to sum. query Object The query argument passed to sum. opts Object The opts argument passed to sum. response Object | Response Count or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 276 Properties: Name Type Description opts.op String afterSum afterUpdate(mapper, id, props, opts, response) Lifecycle method method called by update. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes update to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated record. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by update. Method parameters: Name Type Description mapper Object The mapper argument passed to update. id String | Number The id argument passed to update. props Object The props argument passed to update. opts Object The opts argument passed to update. response Object | Response The updated record or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 300 Properties: Name Type Description opts.op String afterUpdate afterUpdateAll(mapper, props, query, opts, response) Lifecycle method method called by updateAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateAll. Method parameters: Name Type Description mapper Object The mapper argument passed to updateAll. props Object The props argument passed to updateAll. query Object The query argument passed to updateAll. opts Object The opts argument passed to updateAll. response Array.&lt;Object&gt; | Response The updated records or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 324 Properties: Name Type Description opts.op String afterUpdateAll afterUpdateMany(mapper, records, opts, response) Lifecycle method method called by updateMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateMany to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateMany. Method parameters: Name Type Description mapper Object The mapper argument passed to updateMany. records Array.&lt;Object&gt; The records argument passed to updateMany. opts Object The opts argument passed to updateMany. response Array.&lt;Object&gt; | Response The updated records or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 348 Properties: Name Type Description opts.op String afterUpdateMany beforeCount(mapper, query, opts) Lifecycle method method called by count. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes count to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by count. Method parameters: Name Type Description mapper Object The mapper argument passed to count. query Object The query argument passed to count. opts Object The opts argument passed to count. Details Source node_modules/js-data-adapter/src/index.js, line 371 Properties: Name Type Description opts.op String beforeCount beforeCreate(mapper, props, opts) Lifecycle method method called by create. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes create to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by create. Method parameters: Name Type Description mapper Object The mapper argument passed to create. props Object The props argument passed to create. opts Object The opts argument passed to create. Details Source node_modules/js-data-adapter/src/index.js, line 389 Properties: Name Type Description opts.op String beforeCreate beforeCreateMany(mapper, props, opts) Lifecycle method method called by createMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes createMany to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by createMany. Method parameters: Name Type Description mapper Object The mapper argument passed to createMany. props Array.&lt;Object&gt; The props argument passed to createMany. opts Object The opts argument passed to createMany. Details Source node_modules/js-data-adapter/src/index.js, line 409 Properties: Name Type Description opts.op String beforeCreateMany beforeDestroy(mapper, id, opts) Lifecycle method method called by destroy. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroy to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroy. Method parameters: Name Type Description mapper Object The mapper argument passed to destroy. id String | Number The id argument passed to destroy. opts Object The opts argument passed to destroy. Details Source node_modules/js-data-adapter/src/index.js, line 429 Properties: Name Type Description opts.op String beforeDestroy beforeDestroyAll(mapper, query, opts) Lifecycle method method called by destroyAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroyAll to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroyAll. Method parameters: Name Type Description mapper Object The mapper argument passed to destroyAll. query Object The query argument passed to destroyAll. opts Object The opts argument passed to destroyAll. Details Source node_modules/js-data-adapter/src/index.js, line 447 Properties: Name Type Description opts.op String beforeDestroyAll beforeFind(mapper, id, opts) Lifecycle method method called by find. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes find to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by find. Method parameters: Name Type Description mapper Object The mapper argument passed to find. id String | Number The id argument passed to find. opts Object The opts argument passed to find. Details Source node_modules/js-data-adapter/src/index.js, line 465 Properties: Name Type Description opts.op String beforeFind beforeFindAll(mapper, query, opts) Lifecycle method method called by findAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes findAll to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by findAll. Method parameters: Name Type Description mapper Object The mapper argument passed to findAll. query Object The query argument passed to findAll. opts Object The opts argument passed to findAll. Details Source node_modules/js-data-adapter/src/index.js, line 483 Properties: Name Type Description opts.op String beforeFindAll beforeSum(mapper, query, opts) Lifecycle method method called by sum. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes sum to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by sum. Method parameters: Name Type Description mapper Object The mapper argument passed to sum. query Object The query argument passed to sum. opts Object The opts argument passed to sum. Details Source node_modules/js-data-adapter/src/index.js, line 501 Properties: Name Type Description opts.op String beforeSum beforeUpdate(mapper, id, props, opts) Lifecycle method method called by update. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes update to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by update. Method parameters: Name Type Description mapper Object The mapper argument passed to update. id String | Number The id argument passed to update. props Object The props argument passed to update. opts Object The opts argument passed to update. Details Source node_modules/js-data-adapter/src/index.js, line 519 Properties: Name Type Description opts.op String beforeUpdate beforeUpdateAll(mapper, props, query, opts) Lifecycle method method called by updateAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateAll to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateAll. Method parameters: Name Type Description mapper Object The mapper argument passed to updateAll. props Object The props argument passed to updateAll. query Object The query argument passed to updateAll. opts Object The opts argument passed to updateAll. Details Source node_modules/js-data-adapter/src/index.js, line 540 Properties: Name Type Description opts.op String beforeUpdateAll beforeUpdateMany(mapper, props, opts) Lifecycle method method called by updateMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateMany to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateMany. Method parameters: Name Type Description mapper Object The mapper argument passed to updateMany. props Array.&lt;Object&gt; The props argument passed to updateMany. opts Object The opts argument passed to updateMany. Details Source node_modules/js-data-adapter/src/index.js, line 561 Properties: Name Type Description opts.op String beforeUpdateMany count(mapper, query, opts) Retrieve the number of records that match the selection query. Called by Mapper#count. Method parameters: Name Type Argument Description mapper Object The mapper. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy String | Array &lt;optional&gt; Sorting criteria. sort String | Array &lt;optional&gt; Same as query.sort. limit Number &lt;optional&gt; Limit results. skip Number &lt;optional&gt; Offset results. offset Number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 581 create(mapper, props, opts) Create a new record. Called by Mapper#create. Method parameters: Name Type Argument Description mapper Object The mapper. props Object The record to be created. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 627 createMany(mapper, props, opts) Create multiple records in a single batch. Called by Mapper#createMany. Method parameters: Name Type Argument Description mapper Object The mapper. props Object The records to be created. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 669 dbg(args) Log the provided values at the &quot;debug&quot; level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 124 Inherited From: Component#dbg destroy(mapper, id, opts) Destroy the record with the given primary key. Called by Mapper#destroy. Method parameters: Name Type Argument Description mapper Object The mapper. id String | Number Primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 712 destroyAll(mapper, query, opts) Destroy the records that match the selection query. Called by Mapper#destroyAll. Method parameters: Name Type Argument Description mapper Object the mapper. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy String | Array &lt;optional&gt; Sorting criteria. sort String | Array &lt;optional&gt; Same as query.sort. limit Number &lt;optional&gt; Limit results. skip Number &lt;optional&gt; Offset results. offset Number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 750 emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 202 Inherited From: Component#emit Example Try it out // import {Collection, DataStore} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Collection, DataStore} = JSData const collection = new Collection() collection.on('foo', function (msg) { console.log(msg) }) collection.emit('foo', 'bar') const store = new DataStore() store.on('beep', function (msg) { console.log(msg) }) store.emit('beep', 'boop') // import {Collection, DataStore} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Collection, DataStore} = JSData const collection = new Collection() collection.on('foo', function (msg) { console.log(msg) }) collection.emit('foo', 'bar') const store = new DataStore() store.on('beep', function (msg) { console.log(msg) }) store.emit('beep', 'boop') find(mapper, id, opts) Retrieve the record with the given primary key. Called by Mapper#find. Method parameters: Name Type Argument Description mapper Object The mapper. id String | Number Primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 835 findAll(mapper, query, opts) Retrieve the records that match the selection query. Method parameters: Name Type Argument Description mapper Object The mapper. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy String | Array &lt;optional&gt; Sorting criteria. sort String | Array &lt;optional&gt; Same as query.sort. limit Number &lt;optional&gt; Limit results. skip Number &lt;optional&gt; Offset results. offset Number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. with Array.&lt;String&gt; &lt;optional&gt; [] Relations to eager load. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 874 getOpt(opt, opts) Resolve the value of the specified option based on the given options and this adapter's settings. Override with care. Method parameters: Name Type Argument Description opt String The name of the option. opts Object &lt;optional&gt; Configuration options. Return value: Type Description * The value of the specified option. Details Source node_modules/js-data-adapter/src/index.js, line 960 loadBelongsTo() Load a belongsTo relationship. Override with care. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 795 loadHasMany() Load a hasMany relationship. Override with care. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 975 loadHasOne() Load a hasOne relationship. Override with care. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1109 log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 134 Inherited From: Component#log makeBelongsToForeignKey() Return the foreignKey from the given record for the provided relationship. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1178 makeHasManyForeignKey() Return the foreignKey from the given record for the provided relationship. There may be reasons why you may want to override this method, like when the id of the parent doesn't exactly match up to the key on the child. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1132 makeHasManyForeignKeys() Return the foreignKeys from the given record for the provided relationship. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1165 makeHasManyLocalKeys() Return the localKeys from the given record for the provided relationship. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1148 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 180 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler) // Remove a particular listener for a particular event collection.off('add', handler) // Remove all listeners for a particular event record.off('change') // Remove all listeners for a particular event record.off('change') // Remove all listeners to all events store.off() // Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 147 Inherited From: Component#on Examples // Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) // Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) // Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) // Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) // Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' // Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' respond(response, opts) Method parameters: Name Type Description response Object Response object. opts Object Configuration options. return {Object} If opts.raw == true then return response, else return response.data. Details Source node_modules/js-data-adapter/src/index.js, line 1241 sum(mapper, field, query, opts) Retrieve sum of the specified field of the records that match the selection query. Called by Mapper#sum. Method parameters: Name Type Argument Description mapper Object The mapper. field String By to sum. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy String | Array &lt;optional&gt; Sorting criteria. sort String | Array &lt;optional&gt; Same as query.sort. limit Number &lt;optional&gt; Limit results. skip Number &lt;optional&gt; Offset results. offset Number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1191 update(mapper, id, props, opts) Apply the given update to the record with the specified primary key. Called by Mapper#update. Method parameters: Name Type Argument Description mapper Object The mapper. id String | Number The primary key of the record to be updated. props Object The update to apply to the record. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1253 updateAll(mapper, props, query, opts) Apply the given update to all records that match the selection query. Called by Mapper#updateAll. Method parameters: Name Type Argument Description mapper Object The mapper. props Object The update to apply to the selected records. query Object &lt;optional&gt; Selection query. Properties Name Type Argument Description where Object &lt;optional&gt; Filtering criteria. orderBy String | Array &lt;optional&gt; Sorting criteria. sort String | Array &lt;optional&gt; Same as query.sort. limit Number &lt;optional&gt; Limit results. skip Number &lt;optional&gt; Offset results. offset Number &lt;optional&gt; Same as query.skip. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1297 updateMany(mapper, records, opts) Update the given records in a single batch. Called by Mapper#updateMany. Method parameters: Name Type Argument Description mapper Object The mapper. records Array.&lt;Object&gt; The records to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw Boolean &lt;optional&gt; false Whether to return a more detailed response object. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1349  Search results Close api.js-data.io  js-data.io "},"Component.html":{"id":"Component.html","title":"Class: Component","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Class: Component Component new Component(opts) The base class from which all JSData components inherit some basic functionality. Typically you won't instantiate this class directly, but you may find it useful as an abstract class for your own components. See Component.extend for an example of using Component as a base class. import {Component} from 'js-data' Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description debug Boolean &lt;optional&gt; false See Component#debug. Return value: Type Description Component A new Component instance. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 4 Members debug Whether to enable debug-level logs for this component. Anything that extends Component inherits this option and the corresponding logging functionality. Details Type Since Default value Source Boolean 3.0.0 false node_modules/js-data/src/Component.js, line 28 Example Try it out // Normally you would do: import {Component} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Component} = JSData console.log('Using JSData v' + JSData.version.full) const component = new Component() component.log('debug', 'some message') // nothing gets logged // Display debug logs: component.debug = true component.log('debug', 'other message') // this DOES get logged // Normally you would do: import {Component} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Component} = JSData console.log('Using JSData v' + JSData.version.full) const component = new Component() component.log('debug', 'some message') // nothing gets logged // Display debug logs: component.debug = true component.log('debug', 'other message') // this DOES get logged Methods &lt;static&gt; extend(props, classProps) Create a subclass of this Component: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this Component class. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 69 Example Try it out // Normally you would do: import {Component} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Component} = JSData console.log('Using JSData v' + JSData.version.full) // Extend the class using ES2015 class syntax. class CustomComponentClass extends Component { foo () { return 'bar' } static beep () { return 'boop' } } const customComponent = new CustomComponentClass() console.log(customComponent.foo()) console.log(CustomComponentClass.beep()) // Extend the class using alternate method. const OtherComponentClass = Component.extend({ foo () { return 'bar' } }, { beep () { return 'boop' } }) const otherComponent = new OtherComponentClass() console.log(otherComponent.foo()) console.log(OtherComponentClass.beep()) // Extend the class, providing a custom constructor. function AnotherComponentClass () { Component.call(this) this.created_at = new Date().getTime() } Component.extend({ constructor: AnotherComponentClass, foo () { return 'bar' } }, { beep () { return 'boop' } }) const anotherComponent = new AnotherComponentClass() console.log(anotherComponent.created_at) console.log(anotherComponent.foo()) console.log(AnotherComponentClass.beep()) // Normally you would do: import {Component} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Component} = JSData console.log('Using JSData v' + JSData.version.full) // Extend the class using ES2015 class syntax. class CustomComponentClass extends Component { foo () { return 'bar' } static beep () { return 'boop' } } const customComponent = new CustomComponentClass() console.log(customComponent.foo()) console.log(CustomComponentClass.beep()) // Extend the class using alternate method. const OtherComponentClass = Component.extend({ foo () { return 'bar' } }, { beep () { return 'boop' } }) const otherComponent = new OtherComponentClass() console.log(otherComponent.foo()) console.log(OtherComponentClass.beep()) // Extend the class, providing a custom constructor. function AnotherComponentClass () { Component.call(this) this.created_at = new Date().getTime() } Component.extend({ constructor: AnotherComponentClass, foo () { return 'bar' } }, { beep () { return 'boop' } }) const anotherComponent = new AnotherComponentClass() console.log(anotherComponent.created_at) console.log(anotherComponent.foo()) console.log(AnotherComponentClass.beep()) dbg(args) Log the provided values at the &quot;debug&quot; level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 124 emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 202 Example Try it out // import {Collection, DataStore} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Collection, DataStore} = JSData const collection = new Collection() collection.on('foo', function (msg) { console.log(msg) }) collection.emit('foo', 'bar') const store = new DataStore() store.on('beep', function (msg) { console.log(msg) }) store.emit('beep', 'boop') // import {Collection, DataStore} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Collection, DataStore} = JSData const collection = new Collection() collection.on('foo', function (msg) { console.log(msg) }) collection.emit('foo', 'bar') const store = new DataStore() store.on('beep', function (msg) { console.log(msg) }) store.emit('beep', 'boop') log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 134 off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 180 Examples // Remove a particular listener for a particular event collection.off('add', handler) // Remove a particular listener for a particular event collection.off('add', handler) // Remove all listeners for a particular event record.off('change') // Remove all listeners for a particular event record.off('change') // Remove all listeners to all events store.off() // Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 147 Examples // Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) // Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) // Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) // Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) // Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' // Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data'  Search results Close api.js-data.io  js-data.io "},"HttpAdapter.html":{"id":"HttpAdapter.html","title":"Class: HttpAdapter","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Class: HttpAdapter HttpAdapter new HttpAdapter(opts) HttpAdapter class. Method parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description basePath String &lt;optional&gt; '' See HttpAdapter#basePath. debug Boolean &lt;optional&gt; false See HttpAdapter#debug. forceTrailingSlash Boolean &lt;optional&gt; false See HttpAdapter#forceTrailingSlash. http Object &lt;optional&gt; axios See HttpAdapter#http. httpConfig Object &lt;optional&gt; {} See HttpAdapter#httpConfig. suffix String &lt;optional&gt; '' See HttpAdapter#suffix. useFetch Boolean &lt;optional&gt; false See HttpAdapter#useFetch. Details Source See src/index.js, line 139 http://www.js-data.io/docs/js-data-http Example import { DataStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const httpAdapter = new HttpAdapter(); const store = new DataStore(); store.registerAdapter('http', httpAdapter, { 'default': true }); store.defineMapper('school'); store.defineMapper('student'); // GET /school/1 store.find('school', 1).then((school) =&gt; { console.log('school'); }); import { DataStore } from 'js-data'; import { HttpAdapter } from 'js-data-http'; const httpAdapter = new HttpAdapter(); const store = new DataStore(); store.registerAdapter('http', httpAdapter, { 'default': true }); store.defineMapper('school'); store.defineMapper('student'); // GET /school/1 store.find('school', 1).then((school) =&gt; { console.log('school'); }); Extends This class extends the Adapter class. Members basePath Set a base path in order to use absolute URLs instead of relative URLs. Details Type Since Source String 3.0.0 src/index.js, line 71 Example const httpAdapter = new HttpAdapter({ basePath: 'https://mydomain.com' }); const httpAdapter = new HttpAdapter({ basePath: 'https://mydomain.com' }); debug Whether to log debugging information. Details Type Default value Source Boolean false node_modules/js-data-adapter/src/index.js, line 74 Inherited From: Adapter#debug forceTrailingSlash Ensure that the request url has a trailing forward slash. Details Type Since Default value Source Boolean 3.0.0 false src/index.js, line 85 http The HTTP function that actually makes the HTTP request. By default this is axios. Details Type Since Source See Function 3.0.0 src/index.js, line 97 http://www.js-data.io/docs/js-data-http#using-a-custom-http-library httpConfig Default configuration options to be mixed into the config argument passed to HttpAdapter#http. Details Type Since Source Object 3.0.0 src/index.js, line 108 raw Whether to return a more detailed response object. Details Type Default value Source Boolean false node_modules/js-data-adapter/src/index.js, line 83 Inherited From: Adapter#raw suffix Add a suffix to the request url, e.g. &quot;.json&quot;. Details Type Since Source String 3.0.0 src/index.js, line 118 useFetch Use window.fetch if available. Details Type Since Default value Source See Boolean 3.0.0 false src/index.js, line 127 http://www.js-data.io/docs/js-data-http#using-windowfetch Methods &lt;static&gt; extend(props, classProps) Create a subclass of this HttpAdapter: Method parameters: Name Type Argument Default Description props Object &lt;optional&gt; {} Properties to add to the prototype of the subclass. Properties Name Type Argument Description constructor Object &lt;optional&gt; Provide a custom constructor function to be used as the subclass itself. classProps Object &lt;optional&gt; {} Static properties to add to the subclass. Return value: Type Description Constructor Subclass of this HttpAdapter class. Details Since Source 3.0.0 src/index.js, line 1247 Example Try it out // Normally you would do: import { HttpAdapter } from 'js-data-http'; // or: import { HttpAdapter } from 'js-data-http-node'; const JSDataHttp = require('js-data-http-node'); const { HttpAdapter } = JSDataHttp; console.log('Using JSDataHttp v' + JSDataHttp.version.full); // Extend the class using ES2015 class syntax. class CustomHttpAdapterClass extends HttpAdapter { foo () { return 'bar'; } static beep () { return 'boop'; } } const customHttpAdapter = new CustomHttpAdapterClass(); console.log(customHttpAdapter.foo()); console.log(CustomHttpAdapterClass.beep()); // Extend the class using alternate method. const OtherHttpAdapterClass = HttpAdapter.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const otherHttpAdapter = new OtherHttpAdapterClass(); console.log(otherHttpAdapter.foo()); console.log(OtherHttpAdapterClass.beep()); // Extend the class, providing a custom constructor. function AnotherHttpAdapterClass () { HttpAdapter.call(this); this.created_at = new Date().getTime(); } HttpAdapter.extend({ constructor: AnotherHttpAdapterClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherHttpAdapter = new AnotherHttpAdapterClass(); console.log(anotherHttpAdapter.created_at); console.log(anotherHttpAdapter.foo()); console.log(AnotherHttpAdapterClass.beep()); // Normally you would do: import { HttpAdapter } from 'js-data-http'; // or: import { HttpAdapter } from 'js-data-http-node'; const JSDataHttp = require('js-data-http-node'); const { HttpAdapter } = JSDataHttp; console.log('Using JSDataHttp v' + JSDataHttp.version.full); // Extend the class using ES2015 class syntax. class CustomHttpAdapterClass extends HttpAdapter { foo () { return 'bar'; } static beep () { return 'boop'; } } const customHttpAdapter = new CustomHttpAdapterClass(); console.log(customHttpAdapter.foo()); console.log(CustomHttpAdapterClass.beep()); // Extend the class using alternate method. const OtherHttpAdapterClass = HttpAdapter.extend({ foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const otherHttpAdapter = new OtherHttpAdapterClass(); console.log(otherHttpAdapter.foo()); console.log(OtherHttpAdapterClass.beep()); // Extend the class, providing a custom constructor. function AnotherHttpAdapterClass () { HttpAdapter.call(this); this.created_at = new Date().getTime(); } HttpAdapter.extend({ constructor: AnotherHttpAdapterClass, foo () { return 'bar'; } }, { beep () { return 'boop'; } }) const anotherHttpAdapter = new AnotherHttpAdapterClass(); console.log(anotherHttpAdapter.created_at); console.log(anotherHttpAdapter.foo()); console.log(AnotherHttpAdapterClass.beep()); afterCount(mapper, props, opts, response) Lifecycle method method called by count. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes count to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the count. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by count. Method parameters: Name Type Description mapper Object The mapper argument passed to count. props Object The props argument passed to count. opts Object The opts argument passed to count. response Object | Response Count or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 115 Properties: Name Type Description opts.op String afterCount Inherited From: Adapter#afterCount afterCreate(mapper, props, opts, response) Lifecycle method method called by create. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes create to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the created record. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by create. Method parameters: Name Type Description mapper Object The mapper argument passed to create. props Object The props argument passed to create. opts Object The opts argument passed to create. response Object | Response Created record or Response, depending on the value of opts.raw. Details Source Overrides node_modules/js-data-adapter/src/index.js, line 138 Adapter#afterCreate Properties: Name Type Description opts.op String afterCreate Inherited From: Adapter#afterCreate afterDEL(url, config, opts, response) Method parameters: Name Type Description url String config Object opts Object response Object Details Source src/index.js, line 188 afterDestroy(mapper, id, opts, response) Lifecycle method method called by destroy. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroy to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be undefined. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroy. Method parameters: Name Type Description mapper Object The mapper argument passed to destroy. id String | Number The id argument passed to destroy. opts Object The opts argument passed to destroy. response undefined | Response undefined or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 184 Properties: Name Type Description opts.op String afterDestroy Inherited From: Adapter#afterDestroy afterDestroyAll(mapper, query, opts, response) Lifecycle method method called by destroyAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroyAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be undefined. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroyAll. Method parameters: Name Type Description mapper Object The mapper argument passed to destroyAll. query Object The query argument passed to destroyAll. opts Object The opts argument passed to destroyAll. response undefined | Response undefined or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 207 Properties: Name Type Description opts.op String afterDestroyAll Inherited From: Adapter#afterDestroyAll afterFind(mapper, id, opts, response) Lifecycle method method called by find. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes find to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the found record, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by find. Method parameters: Name Type Description mapper Object The mapper argument passed to find. id String | Number The id argument passed to find. opts Object The opts argument passed to find. response Object | Response The found record or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 230 Properties: Name Type Description opts.op String afterFind Inherited From: Adapter#afterFind afterFindAll(mapper, query, opts, response) Lifecycle method method called by findAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes findAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the found records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by findAll. Method parameters: Name Type Description mapper Object The mapper argument passed to findAll. query Object The query argument passed to findAll. opts Object The opts argument passed to findAll. response Array.&lt;Object&gt; | Response The found records or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 253 Properties: Name Type Description opts.op String afterFindAll Inherited From: Adapter#afterFindAll afterGET(url, config, opts, response) Method parameters: Name Type Description url String config Object opts Object response Object Details Source src/index.js, line 198 afterHTTP(config, opts, response) Method parameters: Name Type Description config Object opts Object response Object Details Source src/index.js, line 208 afterPOST(url, data, config, opts, response) Method parameters: Name Type Description url String data Object config Object opts Object response Object Details Source src/index.js, line 217 afterPUT(url, data, config, opts, response) Method parameters: Name Type Description url String data Object config Object opts Object response Object Details Source src/index.js, line 228 afterSum(mapper, field, query, opts, response) Lifecycle method method called by sum. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes sum to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the sum. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by sum. Method parameters: Name Type Description mapper Object The mapper argument passed to sum. field String The field argument passed to sum. query Object The query argument passed to sum. opts Object The opts argument passed to sum. response Object | Response Count or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 276 Properties: Name Type Description opts.op String afterSum Inherited From: Adapter#afterSum afterUpdate(mapper, id, props, opts, response) Lifecycle method method called by update. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes update to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated record. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by update. Method parameters: Name Type Description mapper Object The mapper argument passed to update. id String | Number The id argument passed to update. props Object The props argument passed to update. opts Object The opts argument passed to update. response Object | Response The updated record or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 300 Properties: Name Type Description opts.op String afterUpdate Inherited From: Adapter#afterUpdate afterUpdateAll(mapper, props, query, opts, response) Lifecycle method method called by updateAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateAll to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateAll. Method parameters: Name Type Description mapper Object The mapper argument passed to updateAll. props Object The props argument passed to updateAll. query Object The query argument passed to updateAll. opts Object The opts argument passed to updateAll. response Array.&lt;Object&gt; | Response The updated records or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 324 Properties: Name Type Description opts.op String afterUpdateAll Inherited From: Adapter#afterUpdateAll afterUpdateMany(mapper, records, opts, response) Lifecycle method method called by updateMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateMany to wait for the Promise to resolve before continuing. If opts.raw is true then response will be a detailed response object, otherwise response will be the updated records, if any. response may be modified. You can also re-assign response to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateMany. Method parameters: Name Type Description mapper Object The mapper argument passed to updateMany. records Array.&lt;Object&gt; The records argument passed to updateMany. opts Object The opts argument passed to updateMany. response Array.&lt;Object&gt; | Response The updated records or Response, depending on the value of opts.raw. Details Source node_modules/js-data-adapter/src/index.js, line 348 Properties: Name Type Description opts.op String afterUpdateMany Inherited From: Adapter#afterUpdateMany beforeCount(mapper, query, opts) Lifecycle method method called by count. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes count to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by count. Method parameters: Name Type Description mapper Object The mapper argument passed to count. query Object The query argument passed to count. opts Object The opts argument passed to count. Details Source node_modules/js-data-adapter/src/index.js, line 371 Properties: Name Type Description opts.op String beforeCount Inherited From: Adapter#beforeCount beforeCreate(mapper, props, opts) Lifecycle method method called by create. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes create to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by create. Method parameters: Name Type Description mapper Object The mapper argument passed to create. props Object The props argument passed to create. opts Object The opts argument passed to create. Details Source node_modules/js-data-adapter/src/index.js, line 389 Properties: Name Type Description opts.op String beforeCreate Inherited From: Adapter#beforeCreate beforeCreateMany(mapper, props, opts) Lifecycle method method called by createMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes createMany to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by createMany. Method parameters: Name Type Description mapper Object The mapper argument passed to createMany. props Array.&lt;Object&gt; The props argument passed to createMany. opts Object The opts argument passed to createMany. Details Source node_modules/js-data-adapter/src/index.js, line 409 Properties: Name Type Description opts.op String beforeCreateMany Inherited From: Adapter#beforeCreateMany beforeDEL(url, config, opts) Method parameters: Name Type Description url Object config Object opts Object Details Source src/index.js, line 239 beforeDestroy(mapper, id, opts) Lifecycle method method called by destroy. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroy to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroy. Method parameters: Name Type Description mapper Object The mapper argument passed to destroy. id String | Number The id argument passed to destroy. opts Object The opts argument passed to destroy. Details Source node_modules/js-data-adapter/src/index.js, line 429 Properties: Name Type Description opts.op String beforeDestroy Inherited From: Adapter#beforeDestroy beforeDestroyAll(mapper, query, opts) Lifecycle method method called by destroyAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes destroyAll to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by destroyAll. Method parameters: Name Type Description mapper Object The mapper argument passed to destroyAll. query Object The query argument passed to destroyAll. opts Object The opts argument passed to destroyAll. Details Source node_modules/js-data-adapter/src/index.js, line 447 Properties: Name Type Description opts.op String beforeDestroyAll Inherited From: Adapter#beforeDestroyAll beforeFind(mapper, id, opts) Lifecycle method method called by find. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes find to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by find. Method parameters: Name Type Description mapper Object The mapper argument passed to find. id String | Number The id argument passed to find. opts Object The opts argument passed to find. Details Source node_modules/js-data-adapter/src/index.js, line 465 Properties: Name Type Description opts.op String beforeFind Inherited From: Adapter#beforeFind beforeFindAll(mapper, query, opts) Lifecycle method method called by findAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes findAll to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by findAll. Method parameters: Name Type Description mapper Object The mapper argument passed to findAll. query Object The query argument passed to findAll. opts Object The opts argument passed to findAll. Details Source node_modules/js-data-adapter/src/index.js, line 483 Properties: Name Type Description opts.op String beforeFindAll Inherited From: Adapter#beforeFindAll beforeGET(url, config, opts) Method parameters: Name Type Description url Object config Object opts Object Details Source src/index.js, line 248 beforeHTTP(config, opts) Method parameters: Name Type Description config Object opts Object Details Source src/index.js, line 257 beforePOST(url, data, config, opts) Method parameters: Name Type Description url Object data Object config Object opts Object Details Source src/index.js, line 265 beforePUT(url, data, config, opts) Method parameters: Name Type Description url Object data Object config Object opts Object Details Source src/index.js, line 275 beforeSum(mapper, query, opts) Lifecycle method method called by sum. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes sum to wait for the Promise to resolve before continuing. A thrown error or rejected Promise will bubble up and reject the Promise returned by sum. Method parameters: Name Type Description mapper Object The mapper argument passed to sum. query Object The query argument passed to sum. opts Object The opts argument passed to sum. Details Source node_modules/js-data-adapter/src/index.js, line 501 Properties: Name Type Description opts.op String beforeSum Inherited From: Adapter#beforeSum beforeUpdate(mapper, id, props, opts) Lifecycle method method called by update. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes update to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by update. Method parameters: Name Type Description mapper Object The mapper argument passed to update. id String | Number The id argument passed to update. props Object The props argument passed to update. opts Object The opts argument passed to update. Details Source node_modules/js-data-adapter/src/index.js, line 519 Properties: Name Type Description opts.op String beforeUpdate Inherited From: Adapter#beforeUpdate beforeUpdateAll(mapper, props, query, opts) Lifecycle method method called by updateAll. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateAll to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateAll. Method parameters: Name Type Description mapper Object The mapper argument passed to updateAll. props Object The props argument passed to updateAll. query Object The query argument passed to updateAll. opts Object The opts argument passed to updateAll. Details Source node_modules/js-data-adapter/src/index.js, line 540 Properties: Name Type Description opts.op String beforeUpdateAll Inherited From: Adapter#beforeUpdateAll beforeUpdateMany(mapper, props, opts) Lifecycle method method called by updateMany. Override this method to add custom behavior for this lifecycle hook. Returning a Promise causes updateMany to wait for the Promise to resolve before continuing. props may be modified. You can also re-assign props to another value by returning a different value or a Promise that resolves to a different value. A thrown error or rejected Promise will bubble up and reject the Promise returned by updateMany. Method parameters: Name Type Description mapper Object The mapper argument passed to updateMany. props Array.&lt;Object&gt; The props argument passed to updateMany. opts Object The opts argument passed to updateMany. Details Source node_modules/js-data-adapter/src/index.js, line 561 Properties: Name Type Description opts.op String beforeUpdateMany Inherited From: Adapter#beforeUpdateMany count(mapper, query, opts) Retrieve the number of records that match the selection query. Method parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 371 Adapter#count create(mapper, props, opts) Create a new the record from the provided props. Method parameters: Name Type Argument Description mapper Object The mapper. props Object Properties to send as the payload. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 394 Adapter#create createMany(mapper, props, opts) Create multiple new records in batch. Method parameters: Name Type Argument Description mapper Object The mapper. props Array Array of property objects to send as the payload. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 414 Adapter#createMany dbg(args) Log the provided values at the &quot;debug&quot; level. Debug-level logs are only logged if Component#debug is true. .dbg(...) is shorthand for .log('debug', ...). Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 124 Inherited From: Component#dbg DEL(url, config, opts) Make an Http request to url according to the configuration in config. Method parameters: Name Type Argument Description url String Url for the request. config Object &lt;optional&gt; Http configuration that will be passed to HttpAdapter#HTTP. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Unspecified Details Source src/index.js, line 434 deserialize(mapper, response, opts) Transform the server response object into the payload that will be returned to JSData. Method parameters: Name Type Description mapper Object The mapper used for the operation. response Object Response object from HttpAdapter#HTTP. opts Object Configuration options. Return value: Type Description Object | Array Deserialized data. Details Source src/index.js, line 470 destroy(mapper, id, opts) Destroy the record with the given primary key. Method parameters: Name Type Argument Description mapper Object The mapper. id String | Number Primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 495 Adapter#destroy destroyAll(mapper, query, opts) Destroy the records that match the selection query. Method parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 515 Adapter#destroyAll emit(event, args) Trigger an event on this Component. Method parameters: Name Type Argument Description event String Name of event to emit. args * &lt;optional&gt; &lt;repeatable&gt; Arguments to pass to any listeners. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 202 Inherited From: Component#emit Example Try it out // import {Collection, DataStore} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Collection, DataStore} = JSData const collection = new Collection() collection.on('foo', function (msg) { console.log(msg) }) collection.emit('foo', 'bar') const store = new DataStore() store.on('beep', function (msg) { console.log(msg) }) store.emit('beep', 'boop') // import {Collection, DataStore} from 'js-data' const JSData = require('js-data@3.0.0-rc.4') const {Collection, DataStore} = JSData const collection = new Collection() collection.on('foo', function (msg) { console.log(msg) }) collection.emit('foo', 'bar') const store = new DataStore() store.on('beep', function (msg) { console.log(msg) }) store.emit('beep', 'boop') error(args) Log an error. Method parameters: Name Type Argument Description args * &lt;optional&gt; &lt;repeatable&gt; Arguments to log. Details Source src/index.js, line 537 fetch(config) Make an Http request using window.fetch. Method parameters: Name Type Description config Object Request configuration. Properties Name Type Description data Object Payload for the request. method String Http method for the request. headers Object Headers for the request. params Object Querystring for the request. url String Url for the request. Details Source src/index.js, line 550 find(mapper, id, opts) Retrieve the record with the given primary key. Method parameters: Name Type Argument Description mapper Object The mapper. id String | Number Primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 587 Adapter#find findAll(mapper, query, opts) Retrieve the records that match the selection query. Method parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 607 Adapter#findAll GET(url, config, opts) Make a GET request. Method parameters: Name Type Argument Description url String The url for the request. config Object Request configuration options. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Unspecified Details Source src/index.js, line 629 getEndpoint(mapper, id, opts) Method parameters: Name Type Description mapper Object The Mapper. id * The primary key, if any. opts Boolean Configuration options. Return value: Type Description String Full path. Details Source src/index.js, line 664 getOpt(opt, opts) Resolve the value of the specified option based on the given options and this adapter's settings. Override with care. Method parameters: Name Type Argument Description opt String The name of the option. opts Object &lt;optional&gt; Configuration options. Return value: Type Description * The value of the specified option. Details Source node_modules/js-data-adapter/src/index.js, line 960 Inherited From: Adapter#getOpt getPath(method, mapper, id, opts) Method parameters: Name Type Argument Description method String The method being executed. mapper Object The Mapper. id String | Number &lt;nullable&gt; The primary key, if any. opts Object Configuration options. Details Source src/index.js, line 719 HTTP(config, opts) Make an Http request. Method parameters: Name Type Argument Description config Object Request configuration options. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Unspecified Details Source src/index.js, line 758 loadBelongsTo() Load a belongsTo relationship. Override with care. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 795 Inherited From: Adapter#loadBelongsTo loadHasMany() Load a hasMany relationship. Override with care. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 975 Inherited From: Adapter#loadHasMany loadHasOne() Load a hasOne relationship. Override with care. Return value: Type Description Promise Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1109 Inherited From: Adapter#loadHasOne log(level, args) Log the provided values. By default sends values to console[level]. Debug-level logs are only logged if Component#debug is true. Will attempt to use appropriate console methods if they are available. Method parameters: Name Type Argument Description level String Log level. args * &lt;optional&gt; &lt;repeatable&gt; Values to log. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 134 Inherited From: Component#log makeBelongsToForeignKey() Return the foreignKey from the given record for the provided relationship. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1178 Inherited From: Adapter#makeBelongsToForeignKey makeHasManyForeignKey() Return the foreignKey from the given record for the provided relationship. There may be reasons why you may want to override this method, like when the id of the parent doesn't exactly match up to the key on the child. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1132 Inherited From: Adapter#makeHasManyForeignKey makeHasManyForeignKeys() Return the foreignKeys from the given record for the provided relationship. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1165 Inherited From: Adapter#makeHasManyForeignKeys makeHasManyLocalKeys() Return the localKeys from the given record for the provided relationship. Override with care. Return value: Type Description * Unspecified Details Source node_modules/js-data-adapter/src/index.js, line 1148 Inherited From: Adapter#makeHasManyLocalKeys off(event, listener) Remove an event listener from this Component. If no listener is provided, then all listeners for the specified event will be removed. If no event is specified then all listeners for all events will be removed. Method parameters: Name Type Argument Description event String &lt;optional&gt; Name of event to unsubsribe to. listener Function &lt;optional&gt; Listener to remove. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 180 Inherited From: Component#off Examples // Remove a particular listener for a particular event collection.off('add', handler) // Remove a particular listener for a particular event collection.off('add', handler) // Remove all listeners for a particular event record.off('change') // Remove all listeners for a particular event record.off('change') // Remove all listeners to all events store.off() // Remove all listeners to all events store.off() on(event, listener, ctx) Register a new event listener on this Component. Method parameters: Name Type Argument Description event String Name of event to subsribe to. listener Function Listener function to handle the event. ctx * &lt;optional&gt; Optional content in which to invoke the listener. Details Since Source 3.0.0 node_modules/js-data/src/Component.js, line 147 Inherited From: Component#on Examples // Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) // Listen for all &quot;afterCreate&quot; events in a DataStore store.on('afterCreate', (mapperName, props, opts, result) =&gt; { console.log(mapperName) // &quot;post&quot; console.log(props.id) // undefined console.log(result.id) // 1234 }) store.create('post', { title: 'Modeling your data' }).then((post) =&gt; { console.log(post.id) // 1234 }) // Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) // Listen for the &quot;add&quot; event on a collection collection.on('add', (records) =&gt; { console.log(records) // [...] }) // Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' // Listen for &quot;change&quot; events on a record post.on('change', (record, changes) =&gt; { console.log(changes) // { changed: { title: 'Modeling your data' } } }) post.title = 'Modeling your data' POST(url, data, config, opts) Make a POST request. Method parameters: Name Type Argument Description url * The url for the request. data Object Payload for the request. config Object Request configuration options. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Unspecified Details Source src/index.js, line 831 PUT(url, data, config, opts) Make a PUT request. Method parameters: Name Type Argument Description url * The url for the request. data Object Payload for the request. config Object Request configuration options. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Unspecified Details Source src/index.js, line 868 queryTransform(mapper, params, opts) Transform the querystring object before it is serialized. This doesn't do anything by default. Method parameters: Name Type Description mapper Object The Mapper that triggered the request. params * The querystring object. opts * Configuration options Return value: Type Description * Transformed params. Details Source src/index.js, line 905 respond(response, opts) Method parameters: Name Type Description response Object Response object. opts Object Configuration options. return {Object} If opts.raw == true then return response, else return response.data. Details Source node_modules/js-data-adapter/src/index.js, line 1241 Inherited From: Adapter#respond responseError(err, config, opts) Error handler invoked when the promise returned by HttpAdapter#http is rejected. Default implementation is to just return the error wrapped in a rejected Promise, aka rethrow the error. HttpAdapter#http is called by HttpAdapter#HTTP. Method parameters: Name Type Description err * The error that HttpAdapter#http rejected with. config Object The config argument that was passed to HttpAdapter#HTTP. opts * The opts argument that was passed to HttpAdapter#HTTP. Return value: Type Description Promise Unspecified Details Source src/index.js, line 927 serialize(mapper, data, opts) Serialize request data. This doesn't do anything by default. Method parameters: Name Type Description mapper Object The Mapper that triggered the request. data Object The request payload. opts * Configuration options. Return value: Type Description * Serialized data. Details Source src/index.js, line 944 sum(mapper, field, query, opts) Retrieve the sum of the field of the records that match the selection query. Method parameters: Name Type Argument Description mapper Object The mapper. field String The field to sum. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 965 Adapter#sum update(mapper, id, props, opts) Perform an update. Makes a PUT request by default. Method parameters: Name Type Argument Description mapper Object The Mapper for the request. id * The primary key of the record being updated. props * The update payload. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 992 Adapter#update updateAll(mapper, props, query, opts) Perform an update against records that match the selection query. Makes a PUT request by default. Method parameters: Name Type Argument Description mapper Object The Mapper for the request. props Object The update payload. query Object The selection query. See http://www.js-data.io/docs/query-syntax. opts Object &lt;optional&gt; Configuration options. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 1011 Adapter#updateAll updateMany(mapper, records, opts) Update multiple individual records in a batch. Method parameters: Name Type Argument Description mapper Object The Mapper for the request. records Array Array of property objects to send as the payload. Each must contain the primary key of the record to be updated. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description params String &lt;optional&gt; Querystring parameters. suffix String &lt;optional&gt; HttpAdapter#suffix See HttpAdapter#suffix. Return value: Type Description Promise Unspecified Details Source Overrides src/index.js, line 1033 Adapter#updateMany  Search results Close api.js-data.io  js-data.io "},"module-js-data-http.html":{"id":"module-js-data-http.html","title":"Module: js-data-http","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Module: js-data-http Registered as js-data-http in NPM and Bower. The build of js-data-http that works on Node.js is registered in NPM as js-data-http-node. The build of js-data-http that does not bundle axios is registered in NPM and Bower as js-data-fetch. Details Source src/index.js, line 1218 Examples Try it out var HttpAdapter = window.JSDataHttp.HttpAdapter; var httpAdapter = new HttpAdapter(); var HttpAdapter = window.JSDataHttp.HttpAdapter; var httpAdapter = new HttpAdapter(); Try it out var HttpAdapter = require('js-data-Http').HttpAdapter; var httpAdapter = new HttpAdapter(); var HttpAdapter = require('js-data-Http').HttpAdapter; var httpAdapter = new HttpAdapter(); Try it out import { HttpAdapter } from 'js-data-Http'; const httpAdapter = new HttpAdapter(); import { HttpAdapter } from 'js-data-Http'; const httpAdapter = new HttpAdapter(); Try it out define('myApp', ['js-data-Http'], function (JSDataHttp) { var HttpAdapter = JSDataHttp.HttpAdapter; var httpAdapter = new HttpAdapter(); // ... }); define('myApp', ['js-data-Http'], function (JSDataHttp) { var HttpAdapter = JSDataHttp.HttpAdapter; var httpAdapter = new HttpAdapter(); // ... }); Members &lt;static&gt; HttpAdapter Details Source See src/index.js, line 180 HttpAdapter &lt;static&gt; version Details of the current version of the js-data-http module. Details Type Source Object src/index.js, line 1202 Properties: Name Type Description version.full String The full semver value. version.major Number The major version number. version.minor Number The minor version number. version.patch Number The patch version number. version.alpha String | Boolean The alpha version value, otherwise false if the current version is not alpha. version.beta String | Boolean The beta version value, otherwise false if the current version is not beta. Methods &lt;static&gt; addAction(name, opts) Add an Http actions to a mapper. Method parameters: Name Type Argument Description name String Name of the new action. opts Object &lt;optional&gt; Action configuration Properties Name Type Argument Default Description adapter String &lt;optional&gt; &quot;http&quot; The name of the adapter to use. pathname String &lt;optional&gt; Set the action's pathname. request Function &lt;optional&gt; Specify a request handler to be executed before the request is made. response Function &lt;optional&gt; Specify a response handler to be executed after the response is received. responseError Function &lt;optional&gt; Specify an error handler to be executed on error. Return value: Type Description Function Decoration function, which should be passed the mapper to decorate when invoked. Details Source src/index.js, line 1055 Example // CommonJS var JSData = require('js-data'); // It is recommended to use DataStore in the browser var DataStore = JSData.DataStore; var JSDataHttp = require('js-data-http'); var HttpAdapter = JSDataHttp.HttpAdapter; var addAction = JSDataHttp.addAction; var httpAdapter = new HttpAdapter(); var store = new DataStore(); store.registerAdapter('http', httpAdapter, { 'default': true }); store.defineMapper('school'); // GET /reports/schools/:school_id/teachers addAction('getTeacherReports', { endpoint: 'reports/schools', pathname: 'teachers', method: 'GET' })(store.getMapper('school')); // /reports/schools/1234/teachers store.getMapper('school').getTeacherReports(1234).then((response) =&gt; { // ... }); // CommonJS var JSData = require('js-data'); // It is recommended to use DataStore in the browser var DataStore = JSData.DataStore; var JSDataHttp = require('js-data-http'); var HttpAdapter = JSDataHttp.HttpAdapter; var addAction = JSDataHttp.addAction; var httpAdapter = new HttpAdapter(); var store = new DataStore(); store.registerAdapter('http', httpAdapter, { 'default': true }); store.defineMapper('school'); // GET /reports/schools/:school_id/teachers addAction('getTeacherReports', { endpoint: 'reports/schools', pathname: 'teachers', method: 'GET' })(store.getMapper('school')); // /reports/schools/1234/teachers store.getMapper('school').getTeacherReports(1234).then((response) =&gt; { // ... }); &lt;static&gt; addActions(opts) Add multiple Http actions to a mapper. See HttpAdapter.addAction for action configuration options. Method parameters: Name Type Description opts object.&lt;string, object&gt; Object where the key is an action name and the value is the configuration for the action. Return value: Type Description Function Decoration function, which should be passed the mapper to decorate when invoked. Details Source src/index.js, line 1151 Example // CommonJS var JSData = require('js-data'); // It is recommended to use DataStore in the browser var DataStore = JSData.DataStore; var JSDataHttp = require('js-data-http'); var HttpAdapter = JSDataHttp.HttpAdapter; var addActions = JSDataHttp.addActions; var httpAdapter = new HttpAdapter(); var store = new DataStore(); store.registerAdapter('http', httpAdapter, { 'default': true }); store.defineMapper('school'); addActions({ // GET /reports/schools/:school_id/teachers getTeacherReports: { basePath: 'reports/schools', pathname: 'teachers', method: 'GET' } })(store.getMapper('school')); // /reports/schools/1234/teachers store.getMapper('school').getTeacherReports(1234).then((response) =&gt; { // ... }); // CommonJS var JSData = require('js-data'); // It is recommended to use DataStore in the browser var DataStore = JSData.DataStore; var JSDataHttp = require('js-data-http'); var HttpAdapter = JSDataHttp.HttpAdapter; var addActions = JSDataHttp.addActions; var httpAdapter = new HttpAdapter(); var store = new DataStore(); store.registerAdapter('http', httpAdapter, { 'default': true }); store.defineMapper('school'); addActions({ // GET /reports/schools/:school_id/teachers getTeacherReports: { basePath: 'reports/schools', pathname: 'teachers', method: 'GET' } })(store.getMapper('school')); // /reports/schools/1234/teachers store.getMapper('school').getTeacherReports(1234).then((response) =&gt; { // ... });  Search results Close api.js-data.io  js-data.io "},"Response.html":{"id":"Response.html","title":"Class: Response","body":" js-data-http Modules js-data-http Classes AdapterComponentHttpAdapterResponse Class: Response Response new Response() Response object used when raw is true. May contain other fields in addition to data. Details Source node_modules/js-data-adapter/src/index.js, line 45 Members data Response data. Details Type Source * node_modules/js-data-adapter/src/index.js, line 54 op The operation for which the response was created. Details Type Source String node_modules/js-data-adapter/src/index.js, line 64  Search results Close api.js-data.io  js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
